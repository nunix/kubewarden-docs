<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubewarden Kubernetes Policy Engine</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new
Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('set','anonymizeIp',!0);
ga('create', 'UA-56382716-13', 'auto');
ga('send', 'pageview');
</script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation of Kubewarden project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="tasks.html"><strong aria-hidden="true">3.</strong> Common tasks</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">4.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="writing-policies/index.html"><strong aria-hidden="true">5.</strong> Writing Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/spec/01-intro.html"><strong aria-hidden="true">5.1.</strong> Policy Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/spec/02-settings.html"><strong aria-hidden="true">5.1.1.</strong> Settings</a></li><li class="chapter-item expanded "><a href="writing-policies/spec/03-validating-policies.html"><strong aria-hidden="true">5.1.2.</strong> Validating policies</a></li><li class="chapter-item expanded "><a href="writing-policies/spec/04-mutating-policies.html"><strong aria-hidden="true">5.1.3.</strong> Mutating policies</a></li><li class="chapter-item expanded "><a href="writing-policies/spec/05-context-aware-policies.html"><strong aria-hidden="true">5.1.4.</strong> Context aware policies</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/rust/01-intro.html"><strong aria-hidden="true">5.2.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/rust/02-create-policy.html"><strong aria-hidden="true">5.2.1.</strong> Create a new policy</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/03-define-policy-settings.html"><strong aria-hidden="true">5.2.2.</strong> Define policy settings</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/04-write-validation-logic.html"><strong aria-hidden="true">5.2.3.</strong> Write the validation logic</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/05-mutation-policy.html"><strong aria-hidden="true">5.2.4.</strong> Write a mutation policy</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/06-logging.html"><strong aria-hidden="true">5.2.5.</strong> Logging</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/07-build-and-distribute.html"><strong aria-hidden="true">5.2.6.</strong> Build and distribute</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/rego/01-intro.html"><strong aria-hidden="true">5.3.</strong> Rego</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/rego/open-policy-agent/01-intro.html"><strong aria-hidden="true">5.3.1.</strong> Open Policy Agent</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/rego/open-policy-agent/02-create-policy.html"><strong aria-hidden="true">5.3.1.1.</strong> Create a new policy</a></li><li class="chapter-item expanded "><a href="writing-policies/rego/open-policy-agent/03-build-and-run.html"><strong aria-hidden="true">5.3.1.2.</strong> Build and run</a></li><li class="chapter-item expanded "><a href="writing-policies/rego/open-policy-agent/04-distribute.html"><strong aria-hidden="true">5.3.1.3.</strong> Distribute</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/rego/gatekeeper/01-intro.html"><strong aria-hidden="true">5.3.2.</strong> Gatekeeper</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/rego/gatekeeper/02-create-policy.html"><strong aria-hidden="true">5.3.2.1.</strong> Create a new policy</a></li><li class="chapter-item expanded "><a href="writing-policies/rego/gatekeeper/03-build-and-run.html"><strong aria-hidden="true">5.3.2.2.</strong> Build and run</a></li><li class="chapter-item expanded "><a href="writing-policies/rego/gatekeeper/04-distribute.html"><strong aria-hidden="true">5.3.2.3.</strong> Distribute</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/rego/02-builtin-support.html"><strong aria-hidden="true">5.3.3.</strong> Builtin support</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/go/01-intro.html"><strong aria-hidden="true">5.4.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/go/02-scaffold.html"><strong aria-hidden="true">5.4.1.</strong> Create a new policy</a></li><li class="chapter-item expanded "><a href="writing-policies/go/03-policy-settings.html"><strong aria-hidden="true">5.4.2.</strong> Define policy settings</a></li><li class="chapter-item expanded "><a href="writing-policies/go/04-validation.html"><strong aria-hidden="true">5.4.3.</strong> Write the validation logic</a></li><li class="chapter-item expanded "><a href="writing-policies/go/05-e2e-tests.html"><strong aria-hidden="true">5.4.4.</strong> End-to-end testing</a></li><li class="chapter-item expanded "><a href="writing-policies/go/06-logging.html"><strong aria-hidden="true">5.4.5.</strong> Logging</a></li><li class="chapter-item expanded "><a href="writing-policies/go/07-automate.html"><strong aria-hidden="true">5.4.6.</strong> GitHub Action integration</a></li><li class="chapter-item expanded "><a href="writing-policies/go/08-distribute.html"><strong aria-hidden="true">5.4.7.</strong> Distribute policy</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/swift.html"><strong aria-hidden="true">5.5.</strong> Swift</a></li><li class="chapter-item expanded "><a href="writing-policies/typescript.html"><strong aria-hidden="true">5.6.</strong> TypeScript</a></li></ol></li><li class="chapter-item expanded "><a href="distributing-policies.html"><strong aria-hidden="true">6.</strong> Distributing Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="distributing-policies/custom-certificate-authorities.html"><strong aria-hidden="true">6.1.</strong> Custom Certificate Authorities</a></li><li class="chapter-item expanded "><a href="distributing-policies/oci-registries-support.html"><strong aria-hidden="true">6.2.</strong> OCI Registries support</a></li></ol></li><li class="chapter-item expanded "><a href="testing-policies/01-intro.html"><strong aria-hidden="true">7.</strong> Testing Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing-policies/02-policy-authors.html"><strong aria-hidden="true">7.1.</strong> While creating a policy</a></li><li class="chapter-item expanded "><a href="testing-policies/03-cluster-operators.html"><strong aria-hidden="true">7.2.</strong> Before deployment</a></li></ol></li><li class="chapter-item expanded "><a href="operator-manual/01-intro.html"><strong aria-hidden="true">8.</strong> Operator Manual</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="operator-manual/policy-servers/01-custom-cas.html"><strong aria-hidden="true">8.1.</strong> Configuring PolicyServers</a></li><li class="chapter-item expanded "><a href="operator-manual/telemetry/01-quickstart.html"><strong aria-hidden="true">8.2.</strong> Telemetry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="operator-manual/telemetry/opentelemetry/01-quickstart.html"><strong aria-hidden="true">8.2.1.</strong> OpenTelemetry</a></li><li class="chapter-item expanded "><a href="operator-manual/telemetry/metrics/01-quickstart.html"><strong aria-hidden="true">8.2.2.</strong> Metrics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="operator-manual/telemetry/metrics/02-reference.html"><strong aria-hidden="true">8.2.2.1.</strong> Reference</a></li></ol></li><li class="chapter-item expanded "><a href="operator-manual/telemetry/tracing/01-quickstart.html"><strong aria-hidden="true">8.2.3.</strong> Tracing</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Kubewarden Kubernetes Policy Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/kubewarden/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><strong>WARNING:</strong> Kubewarden is in early development stage, it's not production ready.</p>
<p>Feedback is highly appreciated.</p>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Kubewarden is a <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Kubernetes Dynamic Admission
Controller</a>
that validates incoming requests using policies written in
WebAssembly.</p>
<h2 id="what-is-webassembly"><a class="header" href="#what-is-webassembly">What is WebAssembly?</a></h2>
<p>As stated on <a href="https://webassembly.org/">WebAssembly's official
website</a>:</p>
<blockquote>
<p>WebAssembly (abbreviated Wasm) is a binary instruction format for a
stack-based virtual machine. Wasm is designed as a portable
compilation target for programming languages, enabling deployment on
the web for client and server applications.</p>
</blockquote>
<p>WebAssembly has been originally conceived as an &quot;extension&quot; of
browsers. However, recent efforts have been made by the WebAssembly
community to allow the execution of WebAssembly code outside of
browsers.</p>
<h2 id="why-use-webassembly"><a class="header" href="#why-use-webassembly">Why use WebAssembly?</a></h2>
<p>By using WebAssembly, users can write Kubernetes policies using their
favorite programming language, as long as the language can produce
Wasm binaries.</p>
<p>Policy authors can reuse their skills, tools and best
practices. Policies are &quot;traditional&quot; programs that can have reusable
blocks (regular libraries), can be tested, can be linted, can be
plugged into their current CI and CD workflows,...</p>
<p>Wasm modules are portable, once built they can run on any kind of
processor architecture and Operating System. A policy built on a Apple
Silicon machine can be run on a x86_64 Linux server without any
conversion.</p>
<h2 id="policy-distribution"><a class="header" href="#policy-distribution">Policy distribution</a></h2>
<p>Kubewarden Policies can be served by a regular web server or, even
better, can be published inside of an OCI compliant registry.</p>
<p>Kubewarden Policies can be stored inside of an OCI compliant registry as
<a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>The Kubewarden stack is made of the following components:</p>
<ul>
<li>An arbitrary number of <code>ClusterAdmissionPolicy</code> resources: this is how policies are defined inside Kubernetes</li>
<li>An arbitrary number of <code>PolicyServer</code> resources: this component represents a Deployment of a Kubewarden <code>PolicyServer</code>. The policies defined by the administrators are loaded and evaluated by the Kubewarden <code>PolicyServer</code></li>
<li>A Deployment of <code>kubewarden-controller</code>: this is the controller that monitors the <code>ClusterAdmissionPolicy</code> resources and interacts with the Kubewarden <code>PolicyServer</code> components</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<blockquote>
<p><strong>PREREQUISITES:</strong></p>
<p>Currently, the chart depends on <code>cert-manager</code>. Make sure you have <a href="https://cert-manager.io/docs/installation/"><code>cert-manager</code> installed</a> <em>before</em> installing the <code>kubewarden-controller</code> chart.</p>
<p>You can install the latest version of <code>cert-manager</code> by running the following commands: </p>
</blockquote>
<pre><code class="language-console">kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.yaml

kubectl wait --for=condition=Available deployment --timeout=2m -n cert-manager --all
</code></pre>
<p>The Kubewarden stack can be deployed using <code>helm</code> charts as follows:</p>
<pre><code class="language-console">helm repo add kubewarden https://charts.kubewarden.io

helm install --wait -n kubewarden --create-namespace kubewarden-crds kubewarden/kubewarden-crds

helm install --wait -n kubewarden kubewarden-controller kubewarden/kubewarden-controller
</code></pre>
<p>The following charts should be installed inside the <code>kubewarden</code> namespace in your Kubernetes cluster:</p>
<ul>
<li>
<p><code>kubewarden-crds</code>, which will register the <code>ClusterAdmissionPolicy</code> and <code>PolicyServer</code> Custom Resource Definitions</p>
</li>
<li>
<p><code>kubewarden-controller</code> with a default configuration, and which will create a <code>PolicyServer</code> resource named <code>default</code>. </p>
</li>
</ul>
<blockquote>
<p><strong>QUICK NOTE:</strong></p>
<p>The default configuration values should be good enough for the majority of deployments. All options are documented <a href="https://charts.kubewarden.io/#configuration">here</a>.</p>
</blockquote>
<h2 id="main-components"><a class="header" href="#main-components">Main components</a></h2>
<p>Kubewarden has two main components which you will interact with:</p>
<ul>
<li>The PolicyServer</li>
<li>The ClusterAdmissionPolicy</li>
</ul>
<h3 id="policy-server"><a class="header" href="#policy-server">Policy Server</a></h3>
<p>A Kubewarden Policy Server is completely managed by the <code>kubewarden-controller</code> and multiple Policy Servers can be deployed in the same Kubernetes cluster.</p>
<p>The Policy Server is the component which executes the Kubewarden policies when requests arrive and validates them.</p>
<p>Default <code>PolicyServer</code> configuration:</p>
<pre><code class="language-yaml">apiVersion: policies.kubewarden.io/v1alpha2
kind: PolicyServer
metadata:
  name: reserved-instance-for-tenant-a
spec:
  image: ghcr.io/kubewarden/policy-server:v1.0.0
  replicas: 2
  serviceAccountName: sa
  env:
  - name: KUBEWARDEN_LOG_LEVEL
    value: debug
</code></pre>
<p>Overview of the attributes of the <code>PolicyServer</code> resource:</p>
<table><thead><tr><th align="center">Required</th><th>Placeholder</th><th>Description</th></tr></thead><tbody>
<tr><td align="center">✅</td><td><code>image</code></td><td>The name of the container image</td></tr>
<tr><td align="center">✅</td><td><code>replicas</code></td><td>The number of desired instances</td></tr>
<tr><td align="center">-</td><td><code>serviceAccountName</code></td><td>The name of the <code>ServiceAccount</code> to use for the <code>PolicyServer</code> deployment. If no value is provided, the default <code>ServiceAccount</code> from the namespace, where the <code>kubewarden-controller</code> is installed, will be used</td></tr>
<tr><td align="center">-</td><td><code>env</code></td><td>The list of environment variables</td></tr>
<tr><td align="center">-</td><td><code>annotations</code></td><td>The list of annotations</td></tr>
</tbody></table>
<p>Changing any of these attributes will lead to a rollout of the <code>PolicyServer</code> Deployment with the new configuration.</p>
<h3 id="clusteradmissionpolicy"><a class="header" href="#clusteradmissionpolicy">ClusterAdmissionPolicy</a></h3>
<p>The <code>ClusterAdmissionPolicy</code> resource is the core of the Kubewarden stack. This resource defines how policies evaluate requests.</p>
<p>Enforcing policies is the most common operation which a Kubernetes administrator will perform. You can declare as many policies as you want, and each policy will target one or more specific Kubernetes resources (i.e., <code>pods</code>, <code>Custom Resource</code>). You will also specify the type of operation(s) that will be applied for the targeted resource(s). The operations available are <code>CREATE</code>, <code>UPDATE</code>, <code>DELETE</code> and <code>CONNECT</code>.</p>
<p>Default <code>ClusterAdmissionPolicy</code> configuration:</p>
<pre><code class="language-yaml">apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: psp-capabilities
spec:
  policyServer: reserved-instance-for-tenant-a
  module: registry://ghcr.io/kubewarden/policies/psp-capabilities:v0.1.3
  rules:
  - apiGroups: [&quot;&quot;]
    apiVersions: [&quot;v1&quot;]
    resources: [&quot;pods&quot;]
    operations:
    - CREATE
    - UPDATE
  mutating: true
  settings:
    allowed_capabilities:
    - CHOWN
    required_drop_capabilities:
    - NET_ADMIN
</code></pre>
<p>Overview of the attributes of the <code>ClusterAdmissionPolicy</code> resource:</p>
<table><thead><tr><th align="center">Required</th><th>Placeholder</th><th>Description</th></tr></thead><tbody>
<tr><td align="center">-</td><td><code>policy-server</code></td><td>Identifies an existing <code>PolicyServer</code> object. The policy will be served only by this <code>PolicyServer</code> instance. A <code>ClusterAdmissionPolicy</code> that doesn't have an explicit <code>PolicyServer</code>, will be served by the one named <code>default</code></td></tr>
<tr><td align="center">✅</td><td><code>module</code></td><td>The location of the Kubewarden policy. The following schemes are allowed:</td></tr>
<tr><td align="center"></td><td></td><td>- <code>registry</code>: The policy is downloaded from an <a href="https://github.com/opencontainers/artifacts">OCI artifacts</a> compliant container registry. Example: <code>registry://&lt;OCI registry/policy URL&gt;</code></td></tr>
<tr><td align="center"></td><td></td><td>- <code>http</code>, <code>https</code>: The policy is downloaded from a regular HTTP(s) server. Example: <code>https://&lt;website/policy URL&gt;</code></td></tr>
<tr><td align="center"></td><td></td><td>- <code>file</code>: The policy is loaded from a file in the computer filesystem. Example: <code>file:///&lt;policy WASM binary full path&gt;</code></td></tr>
<tr><td align="center">✅</td><td><code>resources</code></td><td>The Kubernetes resources evaluated by the policy</td></tr>
<tr><td align="center">✅</td><td><code>operations</code></td><td>What operations for the previously given types should be forwarded to this admission policy by the API server for evaluation.</td></tr>
<tr><td align="center">✅</td><td><code>mutating</code></td><td>A boolean value that must be set to <code>true</code> for policies that can mutate incoming requests</td></tr>
<tr><td align="center">-</td><td><code>settings</code></td><td>A free-form object that contains the policy configuration values</td></tr>
<tr><td align="center">-</td><td><code>failurePolicy</code></td><td>The action to take if the request evaluated by a policy results in an error. The following options are allowed:</td></tr>
<tr><td align="center"></td><td></td><td>- <code>Ignore</code>: an error calling the webhook is ignored and the API request is allowed to continue</td></tr>
<tr><td align="center"></td><td></td><td>- <code>Fail</code>: an error calling the webhook causes the admission to fail and the API request to be rejected</td></tr>
</tbody></table>
<p>The complete documentation of this Custom Resource can be found <a href="https://github.com/kubewarden/kubewarden-controller/blob/main/docs/crds/README.asciidoc">here</a> or on <a href="https://doc.crds.dev/github.com/kubewarden/kubewarden-controller">docs.crds.dev</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> The  <code>ClusterAdmissionPolicy</code> resources are registered with a <code>*</code> webhook <code>scope</code>, which means that registered webhooks will forward all requests matching the given <code>resources</code> and <code>operations</code> -- either namespaced (in any namespace), or cluster-wide resources.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> The <code>ClusterAdmissionPolicy</code> resource is cluster-wide. There are plans to also provide a namespaced version that will only impact registered namespaced resources on its own namespace.</p>
</blockquote>
<h2 id="example-enforce-your-first-policy"><a class="header" href="#example-enforce-your-first-policy">Example: Enforce your first policy</a></h2>
<p>For this first example, we will use the <a href="https://github.com/kubewarden/pod-privileged-policy"><code>pod-privileged</code> policy</a>.
Our goal will be to prevent the creation of privileged containers inside our Kubernetes cluster by enforcing this policy.</p>
<p>Let's define a <code>ClusterAdmissionPolicy</code> for that:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: privileged-pods
spec:
  module: registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9
  rules:
  - apiGroups: [&quot;&quot;]
    apiVersions: [&quot;v1&quot;]
    resources: [&quot;pods&quot;]
    operations:
    - CREATE
    - UPDATE
  mutating: false
EOF
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-console">clusteradmissionpolicy.policies.kubewarden.io/privileged-pods created
</code></pre>
<p>When a  <code>ClusterAdmissionPolicy</code> is defined, the status is set to <code>pending</code>, and it will force a rollout of the targeted <code>PolicyServer</code>. In our example, it's the <code>PolicyServer</code> named <code>default</code>. You can monitor the rollout by running the following command:</p>
<pre><code class="language-console">kubectl get clusteradmissionpolicy.policies.kubewarden.io/privileged-pods
</code></pre>
<p>You should see the following output:</p>
<pre><code class="language-console">NAME              POLICY SERVER   MUTATING   STATUS
privileged-pods   default         false      pending
</code></pre>
<p>Once the new policy is ready to be served, the <code>kubewarden-controller</code> will register a <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io">ValidatingWebhookConfiguration</a> object.</p>
<p>The <code>ClusterAdmissionPolicy</code> status will be set to <code>active</code> once the Deployment is done for every <code>PolicyServer</code> instance. The <code>ValidatingWebhookConfiguration</code> can be shown with the following command:</p>
<pre><code class="language-console">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l kubewarden
</code></pre>
<p>You should see the following output:</p>
<pre><code class="language-console">NAME              WEBHOOKS   AGE
privileged-pods   1          9s
</code></pre>
<p>Once the <code>ClusterAdmissionPolicy</code> is active and the <code>ValidatingWebhookConfiguration</code> is registered, you can test the policy.</p>
<p>First, let's create a Pod with a Container <em>not</em> in <code>privileged</code> mode:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: unprivileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
EOF
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-console">pod/unprivileged-pod created
</code></pre>
<p>The Pod is successfully created.</p>
<p>Now, let's create a Pod with at least one Container <code>privileged</code> flag:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
      securityContext:
          privileged: true
EOF
</code></pre>
<p>The creation of the Pod has been denied by the policy and you should see the following message:</p>
<pre><code class="language-console">Error from server: error when creating &quot;STDIN&quot;: admission webhook &quot;privileged-pods.kubewarden.admission&quot; denied the request: User 'minikube-user' cannot schedule privileged containers
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> both examples didn't define a <code>namespace</code>, which means the <code>default</code> namespace was the target. However, as you could see in the second example, the policy is still applied. As stated above, this is due to the scope being cluster-wide and not targeting a specific namespace.</p>
</blockquote>
<h2 id="uninstall"><a class="header" href="#uninstall">Uninstall</a></h2>
<p>You can remove the resources created by uninstalling the <code>helm</code> charts as follow:</p>
<pre><code class="language-console">helm uninstall --namespace kubewarden kubewarden-controller

helm uninstall --namespace kubewarden kubewarden-crds
</code></pre>
<p>Once the <code>helm</code> charts have been uninstalled, you can remove the Kubernetes namespace that was used to deploy the Kubewarden stack:</p>
<pre><code class="language-console">kubectl delete namespace kubewarden
</code></pre>
<blockquote>
<p><strong>Note:</strong> kubewarden contains a helm pre-delete hook that will remove all <code>PolicyServers</code> and <code>kubewarden-controller</code>.
Then the <code>kubewarden-controller</code> will delete all resources, so it is important that <code>kubewarden-controller</code> is running when helm uninstall is executed.</p>
</blockquote>
<p><code>ValidatingWebhookConfigurations</code> and <code>MutatingWebhookConfigurations</code> created by kubewarden should be deleted, this can be checked with:</p>
<pre><code class="language-console">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot;

kubectl get mutatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot;
</code></pre>
<p>If these resources are not automatically removed, you can remove them manually by using the following command:</p>
<pre><code class="language-console">kubectl delete -l &quot;kubewarden&quot; validatingwebhookconfigurations.admissionregistration.k8s.io

kubectl delete -l &quot;kubewarden&quot; mutatingwebhookconfigurations.admissionregistration.k8s.io
</code></pre>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h2>
<p>As we have seen, the <code>ClusterAdmissionPolicy</code> resource is the core type that a cluster operator has to manage, the rest of the resources needed to run the policies and configure them will be taken care of automatically by the <code>kubewarden-controller</code> module.</p>
<p>Now, you are ready to deploy Kubewarden and you can have a look at the policies in <a href="https://hub.kubewarden.io">hub.kubewarden.io</a>, <a href="https://github.com/topics/kubewarden-policy">on Github</a>, or reuse existing Rego policies as shown in the <a href="./writing-policies/rego/01-intro.html">following chapters!</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-tasks"><a class="header" href="#common-tasks">Common Tasks</a></h1>
<p>This page lists a set of tasks that can be performed after you <a href="/quick-start.html#install">install Kubewarden</a> in your Kubernetes cluster.</p>
<p>Each task can be done separately; however, if you're not familiar with Kubewarden, or Kubernetes policies in general, we recommend that you follow the tasks below in sequential order.</p>
<h2 id="test-policies"><a class="header" href="#test-policies">Test Policies</a></h2>
<p>Kubewarden has two main tools to help you find policies and test them locally:</p>
<ul>
<li><a href="https://hub.kubewarden.io/">Kubewarden Policy Hub</a></li>
<li><a href="https://github.com/kubewarden/kwctl"><code>kwctl</code></a> CLI tool</li>
</ul>
<h3 id="kubewarden-policy-hub"><a class="header" href="#kubewarden-policy-hub">Kubewarden Policy Hub</a></h3>
<p>The Kubewarden Policy Hub hosts policies contributed by the community. For example, you can find substitutes to the <a href="https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/">deprecated Kubernetes Pod Security Policies</a>, created by the Kubewarden developers. </p>
<p>As shown in the picture below, once you find the policy to be tested, you can copy the registry path<sup>1</sup> or download<sup>2</sup> the <code>Wasm</code> binary containing the policy and additional metadata:</p>
<p><img src="/images/tasks-policy-hub.png" alt="Kubewarden Policy Hub" /></p>
<p>Once you have the policy <code>Wasm</code> binary or the registry path, you can test it with <code>kwctl</code>.</p>
<h3 id="kwctl-cli-tool"><a class="header" href="#kwctl-cli-tool"><code>kwctl</code> CLI tool</a></h3>
<p><code>kwctl</code> is a Command Line Interface (CLI) tool that will allow both the policy authors and the cluster administrators to test policies before they are applied to the Kubernetes cluster.</p>
<p>The user experience (UX) of this tool is intended to be easy and intuitive like the <code>docker</code> CLI tool. </p>
<h4 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h4>
<p>Depending on your role, <code>kwctl</code> will help you in the following non-exhaustive scenarios:</p>
<p><em>As a policy author</em></p>
<ul>
<li><em>End-to-end testing of your policy</em>: Test your policy against crafted Kubernetes requests and ensure your policy behaves as you expect. You can even test context-aware policies that require access to a running cluster.</li>
<li><em>Embed metadata in your Wasm module</em>: the binary contains annotations of the permissions it needs to be executed</li>
<li><em>Publish policies to OCI registries</em>: The binary is a fully compliant OCI object and can be stored in OCI registries.</li>
</ul>
<p><em>As a cluster administrator</em></p>
<ul>
<li><em>Inspect remote policies</em>: Given a policy in an OCI registry or in an HTTP server, show all static information about the policy.</li>
<li><em>Dry-run of a policy in your cluster</em>: Test the policy against crafted Kubernetes requests and ensure the policy behaves as you expect given the input data you provide. You can even test context-aware policies that require access to a running cluster, also in a dry-run mode.</li>
<li><em>Generate initial <code>ClusterAdmissionPolicy</code> scaffolding for your policy</em>: Generate a <code>YAML</code> file with all the required settings, which can be applied to your Kubernetes cluster using <code>kubectl</code>.</li>
</ul>
<h4 id="installation-1"><a class="header" href="#installation-1">Installation</a></h4>
<p><code>kwctl</code> binaries for the stable releases are directly available from the <a href="https://github.com/kubewarden/kwctl/releases">GitHub repository</a>.</p>
<blockquote>
<p><strong>NOTE</strong>: If you want to build <code>kwctl</code> from the development branch, you need to install <a href="https://www.rust-lang.org/tools/install">Rust</a>. And for building <code>kwctl</code>, please refer to the <code>Build kwctl from source</code> section in the <a href="https://github.com/kubewarden/kwctl">GitHub repo</a>.</p>
</blockquote>
<h4 id="usage"><a class="header" href="#usage">Usage</a></h4>
<p>As stated above, <code>kwctl</code> will allow you to perform an end-to-end testing of the policies.</p>
<p>You can list all the <code>kwctl</code> options and subcommands by running the following command:</p>
<pre><code class="language-shell">$ kwctl --help
kwctl 0.2.4
Flavio Castelli &lt;fcastelli@suse.com&gt;:Rafael Fernández López &lt;rfernandezlopez@suse.com&gt;
Tool to manage Kubewarden policies

USAGE:
    kwctl [FLAGS] &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information
    -v               Increase verbosity

SUBCOMMANDS:
    annotate       Adds Kubewarden metadata to a WebAssembly module
    completions    Generates shell completions
    help           Prints this message or the help of the given subcommand(s)
    inspect        Inspects Kubewarden policy
    manifest       Scaffolds a Kubernetes resource
    policies       Lists all downloaded policies
    pull           Pulls a Kubewarden policy from a given URI
    push           Pushes a Kubewarden policy to an OCI registry
    rm             Removes a Kubewarden policy from the store
    run            Runs a Kubewarden policy from a given URI
    verify         Verifies a Kubewarden policy from a given URI using Sigstore
</code></pre>
<p>Here are a few examples of the commands you should run, depending on the task you want to perform:</p>
<ul>
<li>
<p><em>List the policies</em>: lists all the policies stored in the local <code>kwctl</code> registry</p>
<ul>
<li>Command: <code>kwctl policies</code></li>
</ul>
</li>
<li>
<p><em>Obtain the policy</em>: download and store the policy inside the local <code>kwctl</code> store</p>
<ul>
<li>Command: <code>kwctl pull &lt;policy URI&gt;</code></li>
<li>Example:</li>
</ul>
<pre><code class="language-shell">$ kwctl pull registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9

$ kwctl policies
+--------------------------------------------------------------+----------+---------------+--------------+----------+
| Policy                                                       | Mutating | Context aware | SHA-256      | Size     |
+--------------------------------------------------------------+----------+---------------+--------------+----------+
| registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9 | no       | no            | 59e34f482b40 | 21.86 kB |
+--------------------------------------------------------------+----------+---------------+--------------+----------+
</code></pre>
</li>
<li>
<p><em>Understand how the policy works</em>: inspect the policy metadata</p>
<ul>
<li>Command: <code>kwctl inspect &lt;policy URI&gt;</code></li>
<li>Example:</li>
</ul>
<pre><code class="language-shell">  $ kwctl inspect registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9
  Details
  title:              pod-privileged
  description:        Limit the ability to create privileged containers
  author:             Flavio Castelli
  url:                https://github.com/kubewarden/pod-privileged-policy
  source:             https://github.com/kubewarden/pod-privileged-policy
  license:            Apache-2.0
  mutating:           false
  context aware:      false
  execution mode:     kubewarden-wapc
  protocol version:   1
  
  Annotations
  io.kubewarden.kwctl 0.1.9
  
  Rules
  ────────────────────
  ---
  - apiGroups:
      - &quot;&quot;
    apiVersions:
      - v1
    resources:
      - pods
    operations:
      - CREATE
  ────────────────────
  
  Usage
  This policy doesn't have a configuration. Once enforced, it will reject
  the creation of Pods that have at least a privileged container defined.
</code></pre>
</li>
<li>
<p><em>Evaluate the policy</em>: Assess the policy and, if available, find the right configuration values to match your requirements.</p>
<blockquote>
<p>NOTE: Familiarity with <a href="https://kubernetes.io/docs/reference/">Kubernetes REST APIs</a> is a prerequisite.</p>
</blockquote>
<ul>
<li>
<p>Command: <code>kwctl run -r &lt;&quot;Kubernetes Admission request&quot; file path&gt; -s &lt;&quot;JSON document&quot; file path&gt; &lt;policy URI&gt;</code></p>
</li>
<li>
<p>Scenario 1:</p>
<ul>
<li>
<p>Request to be evaluated: Create a pod with no 'privileged' container</p>
</li>
<li>
<p>Example:</p>
<pre><code class="language-shell">$ kwctl run registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9 -r unprivileged-pod-request.json
{&quot;uid&quot;:&quot;C6E115F4-A789-49F8-B0C9-7F84C5961FDE&quot;,&quot;allowed&quot;:true,&quot;status&quot;:{&quot;message&quot;:&quot;&quot;}}
</code></pre>
<ul>
<li>
<p>Equivalent command with the policy binary downloaded:</p>
<pre><code class="language-shell">`$ kwctl run file://$PWD/pod-privileged-policy.wasm -r unprivileged-pod-request.json
{&quot;uid&quot;:&quot;C6E115F4-A789-49F8-B0C9-7F84C5961FDE&quot;,&quot;allowed&quot;:true,&quot;status&quot;:{&quot;message&quot;:&quot;&quot;}}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Result: The policy allows the request</p>
</li>
</ul>
</li>
<li>
<p>Scenario 2:</p>
<ul>
<li>
<p>Request to be evaluated: Create a pod with at least one 'privileged' container</p>
</li>
<li>
<p>Command: </p>
<pre><code>kwctl run registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9 -r privileged-pod-request.json
</code></pre>
<ul>
<li>Equivalent command with the policy binary downloaded: <code>kwctl run file://$PWD/pod-privileged-policy.wasm -r privileged-pod-request.json</code></li>
</ul>
</li>
<li>
<p>Output:</p>
<pre><code class="language-json">{&quot;uid&quot;:&quot;8EE6AF8C-C8C8-45B0-9A86-CB52A70EC50D&quot;,&quot;allowed&quot;:false,&quot;status&quot;:{&quot;message&quot;:&quot;User 'kubernetes-admin' cannot schedule privileged containers&quot;}}
</code></pre>
</li>
<li>
<p>Result: The policy denies the request</p>
</li>
</ul>
<blockquote>
<p><strong>NOTE</strong>: If you want to see a more complex example, you can read the Kubewarden blog post <a href="https://www.kubewarden.io/blog/2021/06/kwctl-intro-for-kubernetes-administrators/">Introducing <code>kwctl</code> to Kubernetes Administrators</a>.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="enforce-policies"><a class="header" href="#enforce-policies">Enforce Policies</a></h2>
<p>As described in the <a href="/quick-start.html#example-enforce-your-first-policy">Quick Start</a>, you can enforce a policy by defining a <code>ClusterAdmissionPolicy</code> and then deploy it to your cluster using <code>kubectl</code>.</p>
<p><code>kwctl</code> will help to generate a <code>ClusterAdmissionPolicy</code> from the policy you want to enforce. </p>
<p>After you have generated the <code>ClusterAdmissionPolicy</code> and applied it to your Kubernetes cluster, you can follow the steps described in the <a href="/quick-start.html#example-enforce-your-first-policy">Quick Start</a> below:</p>
<ul>
<li>
<p>Generate the <code>ClusterAdmissionPolicy</code> from the policy <code>manifest</code> and save it to a file</p>
<ul>
<li>Command: <code>kwctl manifest -t ClusterAdmissionPolicy &lt;policy URI&gt; &gt; &lt;&quot;policy name&quot;.yaml&gt;</code></li>
<li>Example:</li>
</ul>
<pre><code class="language-shell">$ kwctl manifest -t ClusterAdmissionPolicy registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9
---
apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: privileged-pods
spec:
  module: &quot;registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.9&quot;
  settings: {}
  rules:
    - apiGroups:
        - &quot;&quot;
      apiVersions:
        - v1
      resources:
        - pods
      operations:
        - CREATE
  mutating: false
</code></pre>
<blockquote>
<p>TIP: By default, the <code>name</code> value is set to <code>generated-policy</code>. You might want to edit it before you deploy the <code>ClusterAdmissionPolicy</code>. </p>
<p>NOTE: To avoid confusion, the value above has been set to <code>privileged-pods</code>.</p>
</blockquote>
</li>
<li>
<p>Deploy the <code>ClusterAdmissionPolicy</code> to your Kubernetes cluster</p>
<ul>
<li>Command: <code>kubectl apply -f &lt;&quot;policy name&quot;.yaml&gt;</code></li>
<li>Example:</li>
</ul>
<pre><code class="language-shell">$ kubectl apply -f pod-privileged-policy.yaml
clusteradmissionpolicy.policies.kubewarden.io/privileged-pods created
</code></pre>
</li>
</ul>
<p>Once the <code>ClusterAdmissionPolicy</code> is deployed, the requests sent to your Kubernetes cluster will be evaluated by the policy if they're within the policy scope.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<h3 id="write-policies"><a class="header" href="#write-policies">Write Policies</a></h3>
<p>The <a href="/writing-policies/">Writing Policies</a> section explains how to write policies in different languages and how to export them into Webassembly so that they can be interpreted by Kubewarden.</p>
<h3 id="distribute-policies"><a class="header" href="#distribute-policies">Distribute Policies</a></h3>
<p>The <a href="/distributing-policies/">Distributing Policies</a> section explains how to publish policies to <a href="https://github.com/opencontainers/distribution-spec/blob/main/spec.md">OCI registries</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Kubewarden is a Kubernetes policy engine that uses policies written using
WebAssembly.</p>
<p>The Kubewarden stack is made by the following components:</p>
<ul>
<li>
<p>Kubewarden Custom Resources: these are <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Kubernetes Custom Resources</a>
that simplify the process of managing policies.</p>
</li>
<li>
<p><a href="https://github.com/kubewarden/kubewarden-controller"><code>kubewarden-controller</code></a>:
this is a Kubernetes controller that reconciles Kubewarden's Custom Resources.
This component creates parts of the Kubewarden stack and, most important of
all, translates Kubewarden's concepts into native Kubernetes directives.</p>
</li>
<li>
<p>Kubewarden policies: these are WebAssembly modules that hold the validation
or mutation logic. These are covered in depth inside of <a href="/writing-policies/index.html">this chapter</a>.</p>
</li>
<li>
<p><a href="https://github.com/kubewarden/policy-server"><code>policy-server</code></a>:
this component receives the requests to be validated. It does that
by executing Kubewarden's policies.</p>
</li>
</ul>
<p>At the bottom of the stack, Kubewarden's integrates with Kubernetes using the
concept of <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Dynamic Admission Control</a>.
In particular, Kubewarden operates as a Kubernetes Admission Webhook.
<code>policy-server</code> is the actual Webhook endpoint that is reached by Kubernetes
API server to validate relevant requests.</p>
<p>Kubernetes is made aware of the existence of Kubewarden's Webhook endpoints by
<code>kubewarden-controller</code>. This is done by registering either
a <code>MutatingWebhookConfiguration</code> or a <code>ValidatingWebhookConfiguration</code>
object.</p>
<p>This diagram shows the full architecture overview of a cluster running
the Kubewarden stack:</p>
<p><img src="/images/architecture.png" alt="Full architecture" /></p>
<h2 id="journey-of-a-kubewarden-policy"><a class="header" href="#journey-of-a-kubewarden-policy">Journey of a Kubewarden policy</a></h2>
<p>The architecture diagram from above can be intimidating at first, this
section explains it step by step.</p>
<h3 id="default-policy-server"><a class="header" href="#default-policy-server">Default Policy Server</a></h3>
<p>On a fresh new cluster, the Kubewarden components defined are its Custom
Resource Definitions, the <code>kubewarden-controller</code> Deployment and a <code>PolicyServer</code>
Custom Resource named <code>default</code>.</p>
<p><img src="/images/architecture_sequence_01.png" alt="Defining the first ClusterAdmissionPolicy resource" /></p>
<p><code>kubewarden-controller</code> notices the default <code>PolicyServer</code> resource and, as a result of that,
it creates a Deployment of the <code>policy-server</code> component.</p>
<p>As stated above, Kubewarden works as a Kubernetes Admission Webhook. Kubernetes
dictates that all the Webhook endpoints must be secured with TLS.
<code>kubewarden-controller</code> takes care of setting up this secure communication
by doing these steps:</p>
<ol>
<li>Generate a self-signed Certificate Authority</li>
<li>Use this CA to generate a TLS certificate and a TLS key for the
<code>policy-server</code> Service.</li>
</ol>
<p>All these objects are stored into Kubernetes as Secret resources.</p>
<p>Finally, <code>kubewarden-controller</code> will create the <code>policy-server</code>
Deployment and a Kubernetes ClusterIP Service to expose it inside of
the cluster network.</p>
<h3 id="defining-the-first-policy"><a class="header" href="#defining-the-first-policy">Defining the first policy</a></h3>
<p>This chart shows what happens when the first policy bounded to the default <code>policy-server</code> is defined inside of the
cluster:</p>
<p><img src="/images/architecture_sequence_02.png" alt="Defining the first ClusterAdmissionPolicy resource" /></p>
<p><code>kubewarden-controller</code> notices the new <code>ClusterAdmissionPolicy</code> resource and,
as a result of that, it finds the bounded <code>PolicyServer</code> and reconciles it.</p>
<h3 id="reconciliation-of-policy-server"><a class="header" href="#reconciliation-of-policy-server">Reconciliation of <code>policy-server</code></a></h3>
<p>When a <code>ClusterAdmissionPolicy</code> is created, modified or deleted a reconciliation loop for the <code>PolicyServer</code>
that owns the policy is triggered inside the <code>kubewarden-controller</code>.
In this reconciliation loop, a ConfigMap with all the polices bounded to 
the <code>PolicyServer</code> is created. Then the a Deployment rollout of the
interested <code>policy-server</code> is started. As a result of that, the new <code>policy-server</code>
instance will be started with the updated configuration.</p>
<p>At start time, <code>policy-server</code> reads its configuration and downloads
all the Kubewarden policies. Policies can be downloaded from remote
endpoints like HTTP(s) servers and container registries.</p>
<p>Policies' behaviour can be tuned by users via policy-specific configuration
parameters. Once all the policies are downloaded, <code>policy-server</code> will ensure
the policy settings provided by the user are valid.</p>
<p><code>policy-server</code> performs the validation of policies's settings by
invoking the <code>validate_setting</code> function exposed by each policy.
This topic is covered more in depth inside
of <a href="/writing-policies/spec/01-intro.html">this section</a> of the documentation.</p>
<p><code>policy-server</code> will exit with an error if one or more policies received wrong
configuration parameters from the end user.</p>
<p>If all the policies are properly configured, <code>policy-server</code> will spawn a
pool of worker threads to evaluate incoming requests using the Kubewarden
policies specified by the user.</p>
<p>Finally, <code>policy-server</code> will start a HTTPS server that listens to incoming
validation requests. The web server is secured using the TLS key and certificate
that have been previously created by <code>kubewarden-controller</code>.</p>
<p>Each policy is exposed by the web server via a dedicated path that follows this
naming convention: <code>/validate/&lt;policy ID&gt;</code>.</p>
<p>This is how the cluster looks like once the initialization of <code>policy-server</code>
is completed:</p>
<p><img src="/images/architecture_sequence_03.png" alt="policy-server initialized" /></p>
<h3 id="making-kubernetes-aware-of-the-policy"><a class="header" href="#making-kubernetes-aware-of-the-policy">Making Kubernetes aware of the policy</a></h3>
<p>The <code>policy-server</code> Pods have a
<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/"><code>Readiness Probe</code></a>,
<code>kubewarden-controller</code> relies on that to know when the <code>policy-server</code> Deployment
is ready to evaluate admission reviews.</p>
<p>Once the <code>policy-server</code> Deployment is marked as <code>Ready</code>, <code>kubewarden-controller</code>
will make the Kubernetes API server aware of the new policy by creating either a
<code>MutatingWebhookConfiguration</code> or a <code>ValidatingWebhookConfiguration</code>
object.</p>
<p>Each policy has its dedicated <code>MutatingWebhookConfiguration</code>/<code>ValidatingWebhookConfiguration</code>
which points to the Webhook endpoint served by <code>policy-server</code>. The endpoint
is reachable by the <code>/validate/&lt;policy ID&gt;</code> URL mentioned before.</p>
<p><img src="/images/architecture_sequence_04.png" alt="Kubernetes Webhook endpoint configuration" /></p>
<h3 id="policy-in-action"><a class="header" href="#policy-in-action">Policy in action</a></h3>
<p>Now that all the plumbing has been done, Kubernetes will start sending the
relevant Admission Review requests to the right <code>policy-server</code> endpoint.</p>
<p><img src="/images/architecture_sequence_05.png" alt="Policy in action" /></p>
<p><code>policy-server</code> receives the Admission Request object and, based on the
endpoint that received the request, uses the right policy to evaluate it.</p>
<p>Each policy is evaluated inside of its own dedicated WebAssembly sandbox.
The communication between <code>policy-server</code> (the &quot;host&quot;) and the WebAssembly
policy (the &quot;guest&quot;) is done using the waPC communication protocol. This is
covered in depth inside of <a href="/writing-policies/index.html">this</a>
section of the documentation.</p>
<h2 id="how-multiple-policy-servers-and-policies-are-handled"><a class="header" href="#how-multiple-policy-servers-and-policies-are-handled">How multiple policy servers and policies are handled</a></h2>
<p>A cluster can have multiple policy servers and Kubewarden policies defined. </p>
<p>Benefits of having multiple policy servers:</p>
<ul>
<li>Noisy Namespaces/Tenants generating lots of policy evaluations can be isolated from the rest of the cluster and do not affect other users.</li>
<li>Mission critical policies can be run inside of a Policy Server &quot;pool&quot;, making your whole infrastructure more resilient.</li>
</ul>
<p>Each <code>policy-server</code> is defined via its own <code>PolicyServer</code> resource and each policy is defined via its own
<code>ClusterAdmissionPolicy</code> resource. </p>
<p>This leads back to the initial diagram:</p>
<p><img src="/images/architecture.png" alt="Full architecture" /></p>
<p>A <code>ClusterAdmissionPolicy</code> is bounded to a <code>PolicyServer</code>. <code>ClusterAdmissionPolicies</code> that don't specify any <code>PolicyServer</code>
will be bounded to the <code>PolicyServer</code> named <code>default</code>. If a <code>ClusterAdmissionPolicy</code> references a <code>PolicyServer</code> that doesn't
exist, it will be in an <code>unschedulable</code> state.</p>
<p>Each <code>policy-server</code> defines multiple validation endpoints, one per policy defined
inside of its configuration file. It's also possible to load the same policy
multiple times, just with different configuration parameters.</p>
<p>The Kubernetes API server is made aware of these policy via the
<code>ValidatingWebhookConfiguration</code> and <code>MutatingWebhookConfiguration</code> resources
that are kept in sync by <code>kubewarden-controller</code>.</p>
<p>Finally, the incoming admission requests are then dispatched by the Kubernetes
API server to the right validation endpoint exposed by <code>policy-server</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-kubewarden-policy"><a class="header" href="#what-is-a-kubewarden-policy">What is a Kubewarden policy</a></h1>
<p>In this section we will explain what Kubewarden policies are by using some traditional computing
analogies.</p>
<p>A Kubewarden policy can be seen as a regular program that does one job: it receives
input data, performs some computation against that and it finally returns a response.</p>
<p>The input data are Kubernetes admission requests and the result of the computation
is a validation response, something that tells to Kubernetes whether to accept, reject or
mutate the original input data.</p>
<p>All these operations are performed by a component of Kubewarden that is called
<a href="https://github.com/kubewarden/policy-server">policy-server</a>.</p>
<p>The policy server doesn't bundle any data processing capability. All these capabilities are
added at runtime via add-ons: the Kubewarden policies.</p>
<p>As a consequence, a Kubewarden policy can be seen as a <a href="https://en.wikipedia.org/wiki/Plug-in_%28computing%29">traditional plug-in</a>
of the &quot;policy server&quot; program.</p>
<p>To recap:</p>
<ul>
<li>Kubewarden policies are plug-ins that expose a set of well-defined
functionalities (validate a Kubernetes request object, validate policy settings
provided by the user,...) using a well-defined API</li>
<li>Policy server is the &quot;main&quot; program that loads the plug-ins
(aka policies) and leverages their exposed functionalities to validate or mutate
Kubernetes requests</li>
</ul>
<p>Writing Kubewarden policies consists of writing the validation business logic
and then exposing it through a well-defined API.</p>
<h1 id="programming-language-requirements"><a class="header" href="#programming-language-requirements">Programming language requirements</a></h1>
<p>Kubewarden policies are delivered as <a href="https://webassembly.org/">WebAssembly</a>
binaries.</p>
<p>Policy authors can write policies using any programming language that supports
WebAssembly as a compilation target. The list of supported language is constantly
evolving, <a href="https://github.com/appcypher/awesome-wasm-langs">this page</a>
provides a nice overview of the WebAssembly landscape.</p>
<p>Currently WebAssembly doesn't have an official way to share complex data types
between the host and a WebAssembly guest. To overcome this limitation
Kubewarden policies leverage the <a href="https://github.com/wapc">waPC</a> project, which
provides a bi-directional communication channel.</p>
<p>Because of that your programming language of choice must provide a waPC guest SDK.
If that's not the case, feel free to reach out. We can help you overcome this
limitation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policy-communication-specification"><a class="header" href="#policy-communication-specification">Policy communication specification</a></h1>
<p>The policy evaluator interacts with Kubewarden policies using a well
defined API.  The purpose of this section is to document the API used
by the host ( be it <code>policy-server</code> or <code>kwctl</code>) to communicate with
Kubewarden's policies.</p>
<blockquote>
<p><strong>Note well:</strong> this section of the documentation is a bit low level, you can
jump straight to one of the &quot;language focused&quot; chapters and come back to this
chapter later.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policy-settings"><a class="header" href="#policy-settings">Policy settings</a></h1>
<p>Policy behaviour is not set in stone, it can be configured by providing configuration
details to the policy at runtime. The policy author has full freedom to define
the structure of the policy settings.</p>
<p>Kubewarden takes care of serializing the policy settings into JSON and provide
them to the policy every time it is invoked.</p>
<h2 id="settings-validation"><a class="header" href="#settings-validation">Settings validation</a></h2>
<p>Some policies might want to validate the settings a user provides to ensure
they are correct.</p>
<p>Each policy must register a waPC function called <code>validate_settings</code> that
takes care of validating the policy settings.</p>
<p>The <code>validate_settings</code> function receives as input a JSON representation of
the settings provided by the user. The function validates them and returns
as a response a <code>SettingsValidationResponse</code> object.</p>
<p>The structure of the <code>SettingsValidationResponse</code> object is the following one:</p>
<pre><code class="language-json">{
  // mandatory
  &quot;valid&quot;: &lt;boolean&gt;,

  // optional, ignored if accepted - recommended for rejections
  &quot;message&quot;: &lt;string&gt;,
}
</code></pre>
<p>If the user provided settings are <code>valid</code>, the contents of <code>message</code> are ignored.
Otherwise the contents of <code>message</code> are shown to the user.</p>
<blockquote>
<p><strong>Note well:</strong> Kubewarden's <a href="https://github.com/chimera-kube/policy-server">policy-server</a>
validates all the policy settings provided by users at start time.
The policy-server exits immediately with an error if at least one of its
policies received wrong configuration parameters.</p>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's take as an example the <a href="https://github.com/kubewarden/psp-capabilities">psp-capabilities</a>
policy which has the following configuration format:</p>
<pre><code class="language-yaml">allowed_capabilities:
- CHOWN

required_drop_capabilities:
- NET_ADMIN

default_add_capabilities:
- KILL
</code></pre>
<p>The <code>validate_settings</code> function will receive as input the following JSON
document:</p>
<pre><code class="language-json">{
  &quot;allowed_capabilities&quot;: [
    &quot;CHOWN&quot;
  ],
  &quot;required_drop_capabilities&quot;: [
    &quot;NET_ADMIN&quot;
  ],
  &quot;default_add_capabilities&quot;: [
    &quot;KILL&quot;
  ]
}
</code></pre>
<h1 id="recap"><a class="header" href="#recap">Recap</a></h1>
<p>Each policy must register a waPC function called <code>validate_settings</code> that has
the following API:</p>
<table>
  <thead>
    <tr>
      <th>waPC function name</th>
      <th>Input payload</th>
      <th>Output payload</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>validate_settings</code></td>
      <td>
<pre>
{
  // your policy configuration
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "validate": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  // recommended for rejections
  "message": &lt;string&gt;,
}
</pre>
      </td>
    </tr>
  </tbody>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validating-policies"><a class="header" href="#validating-policies">Validating policies</a></h1>
<p>The Kubewarden policy server receives
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionReview"><code>AdmissionReview</code></a>
objects from the Kubernetes API server. It then forwards the value of
its <code>request</code> attribute (of type
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionRequest"><code>AdmissionRequest</code></a>
key to the policy to be evaluated.</p>
<p>The policy has to evaluate the <code>request</code> and state whether it should be
accepted or not. When the request is rejected, the policy might provide the
explanation message and a specific error code that is going to be shown to the end user.</p>
<p>By convention of the <code>policy-server</code> project, the guest has to expose
a function named <code>validate</code>, exposed through the waPC guest SDK, so
that the <code>policy-server</code> (waPC host) can invoke it.</p>
<p>The <code>validate</code> function receives a <code>ValidationRequest</code> object serialized as JSON and
returns a <code>ValidationResponse</code> object serialized as JSON.</p>
<h2 id="the-validationrequest-object"><a class="header" href="#the-validationrequest-object">The <code>ValidationRequest</code> object</a></h2>
<p>The <code>ValidationRequest</code> is a simple JSON object that is received by the
<code>validate</code> function. It looks like this:</p>
<pre><code class="language-json">{
  &quot;request&quot;: &lt;AdmissionReview.request data&gt;,
  &quot;settings&quot;: {
     // your policy configuration
  }
}
</code></pre>
<p>The <code>settings</code> key points to a free-form JSON document that can hold the policy
specific settings. The previous chapter focused on policies and settings.</p>
<h3 id="a-concrete-example"><a class="header" href="#a-concrete-example">A concrete example</a></h3>
<p>Given the following Kubernetes <code>AdmissionReview</code>:</p>
<pre><code class="language-json">{
  &quot;apiVersion&quot;: &quot;admission.k8s.io/v1&quot;,
  &quot;kind&quot;: &quot;AdmissionReview&quot;,
  &quot;request&quot;: {
    # Random uid uniquely identifying this admission call
    &quot;uid&quot;: &quot;705ab4f5-6393-11e8-b7cc-42010a800002&quot;,

    # Fully-qualified group/version/kind of the incoming object
    &quot;kind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified
    &quot;resource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    &quot;subResource&quot;: &quot;scale&quot;,

    # Fully-qualified group/version/kind of the incoming object in the original request to the API server.
    # This only differs from `kind` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestKind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified in the original request to the API server.
    # This only differs from `resource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestResource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    # This only differs from `subResource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestSubResource&quot;: &quot;scale&quot;,

    # Name of the resource being modified
    &quot;name&quot;: &quot;my-deployment&quot;,
    # Namespace of the resource being modified, if the resource is namespaced (or is a Namespace object)
    &quot;namespace&quot;: &quot;my-namespace&quot;,

    # operation can be CREATE, UPDATE, DELETE, or CONNECT
    &quot;operation&quot;: &quot;UPDATE&quot;,

    &quot;userInfo&quot;: {
      # Username of the authenticated user making the request to the API server
      &quot;username&quot;: &quot;admin&quot;,
      # UID of the authenticated user making the request to the API server
      &quot;uid&quot;: &quot;014fbff9a07c&quot;,
      # Group memberships of the authenticated user making the request to the API server
      &quot;groups&quot;: [&quot;system:authenticated&quot;,&quot;my-admin-group&quot;],
      # Arbitrary extra info associated with the user making the request to the API server.
      # This is populated by the API server authentication layer and should be included
      # if any SubjectAccessReview checks are performed by the webhook.
      &quot;extra&quot;: {
        &quot;some-key&quot;:[&quot;some-value1&quot;, &quot;some-value2&quot;]
      }
    },

    # object is the new object being admitted.
    # It is null for DELETE operations.
    &quot;object&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # oldObject is the existing object.
    # It is null for CREATE and CONNECT operations.
    &quot;oldObject&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # options contains the options for the operation being admitted, like meta.k8s.io/v1 CreateOptions, UpdateOptions, or DeleteOptions.
    # It is null for CONNECT operations.
    &quot;options&quot;: {&quot;apiVersion&quot;:&quot;meta.k8s.io/v1&quot;,&quot;kind&quot;:&quot;UpdateOptions&quot;,...},

    # dryRun indicates the API request is running in dry run mode and will not be persisted.
    # Webhooks with side effects should avoid actuating those side effects when dryRun is true.
    # See http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request for more details.
    &quot;dryRun&quot;: false
  }
}
</code></pre>
<p>The <code>ValidationRequest</code> object would look like that:</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    # Random uid uniquely identifying this admission call
    &quot;uid&quot;: &quot;705ab4f5-6393-11e8-b7cc-42010a800002&quot;,

    # Fully-qualified group/version/kind of the incoming object
    &quot;kind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified
    &quot;resource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    &quot;subResource&quot;: &quot;scale&quot;,

    # Fully-qualified group/version/kind of the incoming object in the original request to the API server.
    # This only differs from `kind` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestKind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified in the original request to the API server.
    # This only differs from `resource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestResource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    # This only differs from `subResource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestSubResource&quot;: &quot;scale&quot;,

    # Name of the resource being modified
    &quot;name&quot;: &quot;my-deployment&quot;,
    # Namespace of the resource being modified, if the resource is namespaced (or is a Namespace object)
    &quot;namespace&quot;: &quot;my-namespace&quot;,

    # operation can be CREATE, UPDATE, DELETE, or CONNECT
    &quot;operation&quot;: &quot;UPDATE&quot;,

    &quot;userInfo&quot;: {
      # Username of the authenticated user making the request to the API server
      &quot;username&quot;: &quot;admin&quot;,
      # UID of the authenticated user making the request to the API server
      &quot;uid&quot;: &quot;014fbff9a07c&quot;,
      # Group memberships of the authenticated user making the request to the API server
      &quot;groups&quot;: [&quot;system:authenticated&quot;,&quot;my-admin-group&quot;],
      # Arbitrary extra info associated with the user making the request to the API server.
      # This is populated by the API server authentication layer and should be included
      # if any SubjectAccessReview checks are performed by the webhook.
      &quot;extra&quot;: {
        &quot;some-key&quot;:[&quot;some-value1&quot;, &quot;some-value2&quot;]
      }
    },

    # object is the new object being admitted.
    # It is null for DELETE operations.
    &quot;object&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # oldObject is the existing object.
    # It is null for CREATE and CONNECT operations.
    &quot;oldObject&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # options contains the options for the operation being admitted, like meta.k8s.io/v1 CreateOptions, UpdateOptions, or DeleteOptions.
    # It is null for CONNECT operations.
    &quot;options&quot;: {&quot;apiVersion&quot;:&quot;meta.k8s.io/v1&quot;,&quot;kind&quot;:&quot;UpdateOptions&quot;,...},

    # dryRun indicates the API request is running in dry run mode and will not be persisted.
    # Webhooks with side effects should avoid actuating those side effects when dryRun is true.
    # See http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request for more details.
    &quot;dryRun&quot;: false
  },
  &quot;settings&quot;: {
    # policy settings
  }
}
</code></pre>
<h2 id="the-validationresponse-object"><a class="header" href="#the-validationresponse-object">The <code>ValidationResponse</code> object</a></h2>
<p>The <code>validate</code> function returns the outcome of its validation using a <code>ValidationResponse</code>
object.</p>
<p>The <code>ValidationResponse</code> is structured in the following way:</p>
<pre><code class="language-json">{
  // mandatory
  &quot;accepted&quot;: &lt;boolean&gt;,

  // optional, ignored if accepted - recommended for rejections
  &quot;message&quot;: &lt;string&gt;,

  // optional, ignored if accepted
  &quot;code&quot;: &lt;integer&gt;,

  // optional, used by mutation policies
  &quot;mutated_object&quot;: &lt;string&gt;
}
</code></pre>
<p>The <code>message</code> and <code>code</code> attributes can be specified when the request
is not accepted. <code>message</code> is a free form textual error. <code>code</code>
represents an HTTP error code.</p>
<p>If the request is accepted, <code>message</code> and <code>code</code>
values will be ignored by the Kubernetes API server if they are
present.</p>
<p>If <code>message</code> or <code>code</code> are provided, and the request is not
accepted, the Kubernetes API server will forward this information as
part of the body of the error returned to the Kubernetes API server
client that issued the rejected request.</p>
<p>The <code>mutated_object</code> is an optional field used only by mutating policies.
This is going to be covered inside of the next chapter.</p>
<h1 id="recap-1"><a class="header" href="#recap-1">Recap</a></h1>
<p>These are the functions a validating policy must implement:</p>
<table>
  <thead>
    <tr>
      <th>waPC function name</th>
      <th>Input payload</th>
      <th>Output payload</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>validate</code></td>
      <td>
<pre>
{
  "request": {
    // AdmissionReview.request data
  },
  "settings": {
    // your policy configuration
  }
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "accepted": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  //recommended for rejections
  "message": &lt;string&gt;,<br>
  // optional, ignored if accepted
  "code": &lt;integer&gt;
}
</pre>
      </td>
    </tr>
    <tr>
      <td><code>validate_settings</code></td>
      <td>
<pre>
{
  // your policy configuration
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "validate": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  // recommended for rejections
  "message": &lt;string&gt;,
}
</pre>
      </td>
    </tr>
  </tbody>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutating-policies"><a class="header" href="#mutating-policies">Mutating policies</a></h1>
<p>Mutation policies are structured in the very same was as validating ones:</p>
<ul>
<li>They have to register a <code>validate</code> and a <code>validate_settings</code> waPC functions</li>
<li>The communication API used between the host and the policy is the very same
as the one used by validating policies.</li>
</ul>
<p>Mutating policies can accept a request and propose a mutation of the incoming
object by returning a <code>ValidationResponse</code> object that looks like that:</p>
<pre><code class="language-json">```json
{
  &quot;accepted&quot;: true,
  &quot;mutated_object&quot;: &lt;object to be created&gt;
}
</code></pre>
<p>The <code>mutated_object</code> field contains the object the policy wants to be created
inside of the Kubernetes cluster serialized to JSON.</p>
<h2 id="a-concrete-example-1"><a class="header" href="#a-concrete-example-1">A concrete example</a></h2>
<p>Let's assume the policy received <code>ValidationRequest</code>:</p>
<pre><code class="language-json">{
  &quot;settings&quot;: {},
  &quot;request&quot;: {
    &quot;operation&quot;: &quot;CREATE&quot;,
    &quot;object&quot;: {
      &quot;apiVersion&quot;: &quot;v1&quot;,
      &quot;kind&quot;: &quot;Pod&quot;,
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;security-context-demo-4&quot;
      },
      &quot;spec&quot;: {
        &quot;containers&quot;: [
        {
          &quot;name&quot;: &quot;sec-ctx-4&quot;,
          &quot;image&quot;: &quot;gcr.io/google-samples/node-hello:1.0&quot;,
          &quot;securityContext&quot;: {
            &quot;capabilities&quot;: {
              &quot;add&quot;: [&quot;NET_ADMIN&quot;, &quot;SYS_TIME&quot;]
            }
          }
        }
        ]
      }
    }
  }
}
</code></pre>
<blockquote>
<p><strong>Note well:</strong> we left some irrelevant fields out of the <code>request</code> object.</p>
</blockquote>
<p>This request is generated because someone tried to create a Pod that would
look like that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo-4
spec:
  containers:
  - name: sec-ctx-4
    image: gcr.io/google-samples/node-hello:1.0
    securityContext:
      capabilities:
        add:
        - NET_ADMIN
        - SYS_TIME
</code></pre>
<p>Let's assume our policy replies with the following <code>ValidationResponse</code>:</p>
<pre><code class="language-json">{
  &quot;accepted&quot;: true,
  &quot;mutated_object&quot;: {
    &quot;apiVersion&quot;: &quot;v1&quot;,
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;security-context-demo-4&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;name&quot;: &quot;sec-ctx-4&quot;,
          &quot;image&quot;: &quot;gcr.io/google-samples/node-hello:1.0&quot;,
          &quot;securityContext&quot;: {
            &quot;capabilities&quot;: {
              &quot;add&quot;: [
                &quot;NET_ADMIN&quot;,
                &quot;SYS_TIME&quot;
              ],
              &quot;drop&quot;: [
                &quot;BPF&quot;
              ]
            }
          }
        }
      ]
    }
  }
}
</code></pre>
<p>That would lead to the request being accepted, but the final Pod would look like
that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo-4
spec:
  containers:
  - name: sec-ctx-4
    image: gcr.io/google-samples/node-hello:1.0
    securityContext:
      capabilities:
        add:
        - NET_ADMIN
        - SYS_TIME
        drop:
        - BPF
</code></pre>
<p>As you can see the policy altered the <code>securityContext.capabilities.drop</code>
section of the only container declared inside of the Pod.</p>
<p>The container is now dropping the <code>BPF</code> capability thanks to our policy.</p>
<h1 id="recap-2"><a class="header" href="#recap-2">Recap</a></h1>
<p>These are the functions a mutating policy must implement:</p>
<table>
  <thead>
    <tr>
      <th>waPC function name</th>
      <th>Input payload</th>
      <th>Output payload</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>validate</code></td>
      <td>
<pre>
{
  "request": {
    // AdmissionReview.request data
  },
  "settings": {
    // your policy configuration
  }
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "accepted": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  // recommended for rejections
  "message": &lt;string&gt;,<br>
  // optional, ignored if accepted
  "code": &lt;integer&gt;, <br>
  // JSON Object to be created
  // Can be used only when the request is accepted
  "mutated_object": &lt;object&gt;
}
</pre>
      </td>
    </tr>
    <tr>
      <td><code>validate_settings</code></td>
      <td>
<pre>
{
  // your policy configuration
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "validate": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  // recommended for rejections
  "message": &lt;string&gt;,
}
</pre>
      </td>
    </tr>
  </tbody>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-aware-policies"><a class="header" href="#context-aware-policies">Context aware policies</a></h1>
<blockquote>
<p><strong>NOTE:</strong> This feature is a work in progress, and not to be depended
upon. Features described here are incomplete and subject to change
at any time until the feature stabilizes.</p>
<p>Feedback is highly appreciated.</p>
</blockquote>
<p>The <code>policy-server</code> has capabilities to expose cluster information to
policies, so that they can take decisions based on other existing
resources, and not only based on the resource they are evaluated in
isolation.</p>
<p>The <code>policy-server</code> being a deployment, is deployed on the Kubernetes
cluster with a specific service account, that is able to list and
watch a subset of Kubernetes resources, meaning:</p>
<ul>
<li>Namespaces</li>
<li>Services</li>
<li>Ingresses</li>
</ul>
<p>This information is exposed to policies (waPC guests) through a
well known procedure call set of endpoints, that allows to retrieve
this cached information.</p>
<p>The result of these procedure calls is the JSON-encoded result of the
list of resources, as provided by Kubernetes.</p>
<p>The <code>policy-server</code> will be the component responsible for refreshing
this information when it considers, and the policy always retrieves
the latest available information exposed by the <code>policy-server</code>.</p>
<h2 id="accessing-the-cluster-context"><a class="header" href="#accessing-the-cluster-context">Accessing the cluster context</a></h2>
<p>Language SDK's that support cluster context at this time will expose
functions that allow policies to retrieve the current state of the
cluster.</p>
<p>The workflow we have seen until now has been that the policy exposes
well known waPC functions, namely: <code>validate</code> and
<code>validate_settings</code>. At some point, the host will call these functions
when it requires either to validate a request, or to validate the
settings that were provided to it for the given policy.</p>
<p>In this case, after the host calls to the <code>validate</code> waPC function in
the guest, the guest is able to retrieve cluster information in order
to produce a response to the <code>validate</code> waPC function that was called
by the host on the guest.</p>
<p>This guest-host intercommunication is performed using the regular waPC
host calling mechanism, and so any guest implementing the waPC
intercommunication mechanism is able to request this information from
the host.</p>
<p>waPC has the following function arguments when performing a call from
the guest to the host:</p>
<ul>
<li>Binding</li>
<li>Namespace</li>
<li>Operation</li>
<li>Payload</li>
</ul>
<p>By contract, or convention, policies can retrieve the Kubernetes
cluster information by calling the host in the following ways:</p>
<table>
  <thead>
    <tr>
      <th>Binding</th>
      <th>Namespace</th>
      <th>Operation</th>
      <th>Input payload</th>
      <th>Output payload (JSON format)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kubernetes</code></td>
      <td><code>ingresses</code></td>
      <td><code>list</code></td>
      <td>N/A</td>
      <td>Result of <code>GET /apis/networking.k8s.io/v1/ingresses</code></td>
    </tr>
    <tr>
      <td><code>kubernetes</code></td>
      <td><code>namespaces</code></td>
      <td><code>list</code></td>
      <td>N/A</td>
      <td>Result of <code>GET /apis/v1/namespaces</code></td>
    </tr>
    <tr>
      <td><code>kubernetes</code></td>
      <td><code>services</code></td>
      <td><code>list</code></td>
      <td>N/A</td>
      <td>Result of <code>GET /apis/v1/services</code></td>
    </tr>
  </tbody>
</table>
<p>The request the waPC guest performs to the host is local, and served
from a cache -- this request does not get forwarded to the Kubernetes
API server. The policy-server (host) decides when to refresh this
information from the Kubernetes API server.</p>
<blockquote>
<p><strong>NOTE:</strong> This is a proof-of-concept at this time, there are plans
to generalize what resources can be fetched from the cluster, to
include all built-in Kubernetes types, as well as custom resources.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> is the most mature programming language that
can generate WebAssembly modules: WebAssembly is a first-class citizen
in the Rust world. That means many of the tools and crates of the Rust
ecosystem work out of the box.</p>
<p>Kubewarden provides a <a href="https://crates.io/crates/kubewarden-policy-sdk">Rust SDK</a>
that simplifies the process of writing policies, plus a
<a href="https://github.com/kubewarden/rust-policy-template">template project</a> to
quickly scaffold a policy project using the
<a href="https://github.com/cargo-generate/cargo-generate"><code>cargo-generate</code></a> utility.</p>
<p>This document illustrates how to take advantage of these projects to write
Kubewarden policies using the Rust programming language.</p>
<p>Note well, we won't cover the details of Kubewarden's Rust SDK inside of this
page. These can be found inside of the
<a href="https://docs.rs/kubewarden-policy-sdk/0.1.0">official crate documentation</a>.</p>
<h2 id="getting-rust-dependencies"><a class="header" href="#getting-rust-dependencies">Getting Rust dependencies</a></h2>
<p>This section guides you through the process of installing the Rust compiler and
its dependencies.</p>
<p>As a first step install the Rust compiler and its tools, this can be easily done
using <a href="https://github.com/rust-lang/rustup">rustup</a>. Please follow
<a href="https://rust-lang.github.io/rustup/installation/index.html">rustup's install documentation</a>.</p>
<p>Once <code>rustup</code> is installed add the Wasm target:</p>
<pre><code class="language-shell">rustup target add wasm32-unknown-unknown
</code></pre>
<h2 id="osx-specific-dependencies"><a class="header" href="#osx-specific-dependencies">OSX specific dependencies</a></h2>
<p>In order to use <code>cargo-generate</code> you will need to add the Xcode tool set. If it isn't installed through Xcode the following command will give you the dependencies needed:</p>
<pre><code class="language-shell">xcode-select --install
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-validation-policy"><a class="header" href="#creating-a-new-validation-policy">Creating a new validation policy</a></h1>
<p>We are going to create a simple validation policy that processes
Pod creation requests.</p>
<p>The policy will look at the <code>metadata.name</code> attribute of the Pod and reject
the pods that have an invalid name. We want the list of invalid names to be
configurable by the end users of the policy.</p>
<p>To summarize, the policy settings will look like that:</p>
<pre><code class="language-yaml">invalid_names:
- bad_name1
- bad_name2
</code></pre>
<p>The policy will accept the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>While it will reject the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: bad_name1
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h2 id="scaffolding-new-policy-project"><a class="header" href="#scaffolding-new-policy-project">Scaffolding new policy project</a></h2>
<p>The creation of a new policy project can be done by feeding this
<a href="https://github.com/kubewarden/rust-policy-template">template project</a>
into <code>cargo generate</code>.</p>
<p>First, install <code>cargo-generate</code>. Note, this requires <a href="https://pkgs.org/download/openssl-devel">openssl-devel</a>.</p>
<pre><code>cargo install cargo-generate
</code></pre>
<p>Now scaffold the project as follows:</p>
<pre><code class="language-shell">cargo generate --git https://github.com/kubewarden/rust-policy-template \
               --branch main \
               --name demo
</code></pre>
<p>The command will produce the following output:</p>
<pre><code>🔧   Creating project called `demo`...
✨   Done! New project created /home/flavio/hacking/kubernetes/kubewarden/demo
</code></pre>
<p>The new policy project can now be found inside of the <code>demo</code> directory.</p>
<p>Note: if you plan to make use of the GitHub container registry
functionality in the demo, you will need to
<a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/enabling-improved-container-support-with-the-container-registry#enabling-the-container-registry-for-your-personal-account">enable improved container support</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-policy-settings"><a class="header" href="#defining-policy-settings">Defining policy settings</a></h1>
<p>As a first step we will define the structure that holds the policy settings.</p>
<p>Open the <code>src/settings.rs</code> file and change the definition of the <code>Settings</code>
struct to look like that:</p>
<pre><code class="language-rust norun noplayground">use std::collections::HashSet;

#[derive(Deserialize, Default, Debug, Serialize)]
#[serde(default)]
pub(crate) struct Settings {
    pub invalid_names: HashSet&lt;String&gt;,
}
</code></pre>
<p>This will automatically put the list of invalid names inside of
a Set collection.</p>
<p>Next we will write a settings validation function: we want to ensure
the policy is always run with at least one invalid name.</p>
<p>This can be done by changing the implementation of the <code>Validatable</code> trait.</p>
<p>Change the scaffolded implementation defined inside of <code>src/settings.rs</code>
to look like that:</p>
<pre><code class="language-rust norun noplayground">impl kubewarden::settings::Validatable for Settings {
    fn validate(&amp;self) -&gt; Result&lt;(), String&gt; {
        if self.invalid_names.is_empty() {
            Err(String::from(&quot;No invalid name specified. Specify at least one invalid name to match&quot;))
        } else {
            Ok(())
        }
    }
}
</code></pre>
<h2 id="add-unit-tests"><a class="header" href="#add-unit-tests">Add unit tests</a></h2>
<p>Now we can write a unit test to ensure the settings validation is actually working.
This can be done in the <a href="https://doc.rust-lang.org/stable/book/ch11-00-testing.html">usual Rust way</a>.</p>
<p>There are already some default tests at the bottom of the <code>src/settings.rs</code>
file. Replace the automatically generated code to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::settings::Validatable;

    #[test]
    fn accept_settings_with_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        invalid_names.insert(String::from(&quot;bad_name2&quot;));

        let settings = Settings { invalid_names };

        assert!(settings.validate().is_ok());
        Ok(())
    }

    #[test]
    fn reject_settings_without_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let invalid_names = HashSet::&lt;String&gt;::new();
        let settings = Settings { invalid_names };

        assert!(settings.validate().is_err());
        Ok(())
    }
}
</code></pre>
<p>We can now run the unit tests by doing:</p>
<pre><code class="language-shell">cargo test
</code></pre>
<p>This will produce an output similar to the following one:</p>
<pre><code class="language-shell">  Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.19s
     Running target/debug/deps/demo-24670dd6a538fd72

running 2 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-validation-logic"><a class="header" href="#writing-the-validation-logic">Writing the validation logic</a></h1>
<p>It's time to write the actual validation code. This is defined inside of the
<code>src/lib.rs</code> file. Inside of this file you will find a function called <code>validate</code>.</p>
<p>The scaffolded function is already doing something:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    // NOTE 1
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    // NOTE 2
    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            // NOTE 3
            if pod.metadata.name == Some(&quot;invalid-pod-name&quot;.to_string()) {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod.metadata.name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // NOTE 4
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>This is a walk-through the code described above:</p>
<ol>
<li>Parse the incoming <code>payload</code> into a <code>ValidationRequest&lt;Setting&gt;</code> object. This
automatically populates the <code>Settings</code> instance inside of <code>ValidationRequest</code> with
the params provided by the user.</li>
<li>Convert the Kubernetes raw JSON object embedded into the request
into an instance of the <a href="https://arnavion.github.io/k8s-openapi/v0.11.x/k8s_openapi/api/core/v1/struct.Pod.html">Pod struct</a></li>
<li>The request contains a Pod object, the code approves only the requests
that do not have <code>metadata.name</code> equal to the hard-coded value <code>invalid-pod-name</code></li>
<li>The request doesn't contain a Pod object, hence the policy accepts the request</li>
</ol>
<p>As you can see the code is already doing a validation that resembles the one we
want to implement. We just have to get rid of the hard-coded value and use the
values provided by the user via the policy settings.</p>
<p>This can be done with the following code:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            let pod_name = pod.metadata.name.unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>Finally, we will create some unit tests to ensure the validation code works as
expected.</p>
<p>The <code>lib.rs</code> file has already some tests defined at the bottom of the file, as
you can see Kubewarden's Rust SDK provides some test helpers too.</p>
<p>Moreover, the scaffolded project already ships with some default
<a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a> inside of
the <code>test_data</code> directory. We are going to take advantage of these recorded
admission requests to write our unit tests.</p>
<p>Change the contents of the test section inside of <code>src/lib.rs</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::test::Testcase;
    use std::collections::HashSet;

    #[test]
    fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with valid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn reject_pod_with_invalid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;nginx&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with invalid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: false,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn accept_request_with_non_pod_resource() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;prod&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/ingress_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Ingress creation&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }
}
</code></pre>
<p>We now have three unit tests defined inside of this file:</p>
<ul>
<li><code>accept_pod_with_valid_name</code>: ensures a Pod with a valid
name is accepted</li>
<li><code>reject_pod_with_invalid_name</code>: ensures a Pod with an invalid
name is rejected</li>
<li><code>accept_request_with_non_pod_resource</code>: ensure the policy accepts
request that do not have a <code>Pod</code> as object</li>
</ul>
<p>We can run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 3.45s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::accept_pod_with_valid_name ... ok
test tests::reject_pod_with_invalid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>That's all if you want to write a simple validating policy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-mutation-policy"><a class="header" href="#creating-a-new-mutation-policy">Creating a new mutation policy</a></h1>
<p>Mutating policies are similar to validating ones, but have also the ability to mutate an
incoming object.</p>
<p>They can:</p>
<ul>
<li>Reject a request</li>
<li>Accept a request without doing any change to the incoming object</li>
<li>Mutate the incoming object as they like and accept the request</li>
</ul>
<p>Writing a Kubewarden mutation policies is extremely simple. We will use the validating
policy created inside of the previous steps and, with very few changes, turn it into a
mutating one.</p>
<p>Our policy will use the same validation logic defined before, but it will also add
an annotation to all the Pods that have a valid name.</p>
<p>Attempting to create a Pod like that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>Will lead to the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  annotations:
    kubewarden.policy.demo/inspected: true
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h2 id="write-the-mutation-code"><a class="header" href="#write-the-mutation-code">Write the mutation code</a></h2>
<p>The mutation code is done inside of the <code>validate</code> function. The function should be changed
to approve the request via the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.mutate_request.html"><code>mutate_request</code></a>
instead of the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.accept_request.html"><code>accept_request</code></a>.</p>
<p>This is how the <code>validate</code> function has to look like:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        // NOTE 1
        Ok(mut pod) =&gt; {
            let pod_name = pod.metadata.name.clone().unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                // NOTE 2
                let mut new_annotations = pod.metadata.annotations.clone().unwrap_or_default();
                new_annotations.insert(
                    String::from(&quot;kubewarden.policy.demo/inspected&quot;),
                    String::from(&quot;true&quot;),
                );
                pod.metadata.annotations = Some(new_annotations);

                // NOTE 3
                let mutated_object = serde_json::to_value(pod)?;
                kubewarden::mutate_request(mutated_object)
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>Compared to the previous code, we made only three changes:</p>
<ol>
<li>We defined the <code>pod</code> object as mutable, see the <code>mut</code> keyword. This is
needed because we will extend its <code>metadata.annotations</code> attribute</li>
<li>This is the actual code that takes the existing <code>annotations</code>, adds the
new one, and finally puts the updated <code>annotations</code> object back into the original
<code>pod</code> instance</li>
<li>Serialize the <code>pod</code> object into a generic <code>serde_json::Value</code> and then return
a mutation response</li>
</ol>
<p>Having done these changes, it's time to run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.53s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... FAILED
test tests::accept_request_with_non_pod_resource ... ok

failures:

---- tests::accept_pod_with_valid_name stdout ----
thread 'tests::accept_pod_with_valid_name' panicked at 'Something mutated with test case: Pod creation with valid name', src/lib.rs:74:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accept_pod_with_valid_name

test result: FAILED. 4 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see, the <code>accept_pod_with_valid_name</code> fails because the response actually
contains a mutated object. It looks like our code is actually working!</p>
<h2 id="update-the-unit-tests"><a class="header" href="#update-the-unit-tests">Update the unit tests</a></h2>
<p>Let's update the <code>accept_pod_with_valid_name</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[test]
fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
    let mut invalid_names = HashSet::new();
    invalid_names.insert(String::from(&quot;bad_name1&quot;));
    let settings = Settings { invalid_names };

    let request_file = &quot;test_data/pod_creation.json&quot;;
    let tc = Testcase {
        name: String::from(&quot;Pod creation with valid name&quot;),
        fixture_file: String::from(request_file),
        expected_validation_result: true,
        settings,
    };

    let res = tc.eval(validate).unwrap();
    // NOTE 1
    assert!(
        res.mutated_object.is_some(),
        &quot;Expected accepted object to be mutated&quot;,
    );

    // NOTE 2
    let final_pod =
        serde_json::from_str::&lt;apicore::Pod&gt;(res.mutated_object.unwrap().as_str()).unwrap();
    let final_annotations = final_pod.metadata.annotations.unwrap();
    assert_eq!(
        final_annotations.get_key_value(&quot;kubewarden.policy.demo/inspected&quot;),
        Some((
            &amp;String::from(&quot;kubewarden.policy.demo/inspected&quot;),
            &amp;String::from(&quot;true&quot;)
        )),
    );

    Ok(())
}
</code></pre>
<p>Compared to the initial test, we made only two changes:</p>
<ol>
<li>Change the <code>assert!</code> statement to ensure the request is still accepted,
but it also includes a mutated object</li>
<li>Created a <code>Pod</code> instance starting from the mutated object that is part of
the response. Assert the mutated Pod object contains the right
<code>metadata.annotations</code>.</li>
</ol>
<p>We can run the tests again, this time all of them will pass:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 2.61s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see the creation of a mutation policy is pretty straightforward.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>You can perform logging in your policy, so the <code>policy-server</code> or <code>kwctl</code> will forward those log
entries with the appropriate information.</p>
<p>The logging library chosen for the Rust SDK is <a href="https://github.com/slog-rs/slog"><code>slog</code></a>, as it is a
well known crate and integrates in a very straightforward way with Kubewarden.</p>
<h2 id="initialize-logger"><a class="header" href="#initialize-logger">Initialize logger</a></h2>
<p>We recommend that you create a global sink where you can log from where you need within your policy. For this, we will use the <code>lazy_static</code> crate:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use slog::{o, Logger};

lazy_static! {
    static ref LOG_DRAIN: Logger = Logger::root(
        logging::KubewardenDrain::new(),
        o!(&quot;policy&quot; =&gt; &quot;sample-policy&quot;)
    );
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="consuming-the-logger"><a class="header" href="#consuming-the-logger">Consuming the logger</a></h2>
<p>Now, from within our <code>validate</code>, or <code>validate_settings</code> functions, we are able to log using the macros exported by <code>slog</code> that match each supported logging level:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use slog::{info, o, warn, Logger};

fn validate(payload: &amp;[u8]) -&gt; CallResult {
    // ...
    info!(LOG_DRAIN, &quot;starting validation&quot;);
    // ...
    warn!(
        LOG_DRAIN, &quot;structured log&quot;;
        &quot;some_resource_name&quot; =&gt; &amp;some_resource_name
    );
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>slog</code> library will send all logs to the drain we initialized in the global variable, that will
get sinked to the policy evaluator executing the policy, <code>kwctl</code> or the <code>policy-server</code>. Then the
policy evaluator will log this information, adding more contextual information it knows about, such
as the Kubernetes request <code>uid</code>.</p>
<p>More information about the <a href="https://docs.rs/slog/2.7.0/slog/macro.log.html">logging macros</a> offered
by slog can be found inside of <a href="https://docs.rs/slog/2.7.0/slog/index.html">its documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-the-policy"><a class="header" href="#building-the-policy">Building the policy</a></h2>
<p>So far we have built the policy using as a compilation target the same operating
system and architecture of our development machine.</p>
<p>It's now time to build the policy as a WebAssembly binary, also known as <code>.wasm</code>
file.</p>
<p>This can be done with a simple command:</p>
<pre><code class="language-shell">make build
</code></pre>
<p>This command will build the code in release mode, with WebAssembly as
compilation target.</p>
<p>The build will produce the following file:</p>
<pre><code class="language-shell">$ file target/wasm32-unknown-unknown/release/demo.wasm
target/wasm32-unknown-unknown/release/demo.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
</code></pre>
<h2 id="distributing-the-policy"><a class="header" href="#distributing-the-policy">Distributing the policy</a></h2>
<p>This topic is covered inside of the <a href="writing-policies/rust//distributing-policies.html">distributing
policies</a> section of Kubewarden's
documentation.</p>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p>You can find more Kubewarden policies written in Rust inside of Kubewarden's
GitHub space. <a href="https://github.com/search?l=Rust&amp;q=topic%3Apolicy-as-code+org%3Akubewarden&amp;type=Repositories">This query</a>
can help you find them.</p>
<p><strong>Worth of note:</strong> these repositories have a series of GitHub Actions that automate
the following tasks:</p>
<ul>
<li>Run unit tests and code linting on pull requests and after code is merged
into the main branch</li>
<li>Build the policy in <code>release</code> mode and push it to a OCI registry as an
artifact</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rego"><a class="header" href="#rego">Rego</a></h1>
<blockquote>
<p><strong>Note well:</strong> Rego support has been introduced starting from these releases:</p>
<ul>
<li>kwctl: v0.2.0</li>
<li>policy-server: v0.2.0</li>
</ul>
</blockquote>
<p>The Rego language is a tailor made language designed to embrace
policies as
code. <a href="https://www.openpolicyagent.org/docs/latest/policy-language/">Rego</a>
is a language inspired by Datalog.</p>
<p>There are two ways of writing Rego policies as of today in order to
implement policies as code in Kubernetes: Open Policy Agent and
Gatekeeper.</p>
<h2 id="one-language-two-frameworks"><a class="header" href="#one-language-two-frameworks">One language. Two frameworks</a></h2>
<h3 id="open-policy-agent"><a class="header" href="#open-policy-agent">Open Policy Agent</a></h3>
<p>Open Policy Agent is a project that allows you to implement policies
as code in any project. You can rely on Open Policy Agent for any
policy based check that you might require in your own application,
that will in turn execute the required Rego policies.</p>
<p>In this context, writing policies for Kubernetes is just another way
of exercising Open Policy Agent. By using Kubernetes admission
webhooks, it's possible to evaluate requests using Open Policy Agent,
that will in turn execute the policies written in Rego.</p>
<p>Open Policy Agent has some optional integration with Kubernetes
through its <code>kube-mgmt</code> sidecar. When deployed on top of Kubernetes
and next to the Open Policy Agent server evaluating the Rego policies,
it is able to replicate the configured Kubernetes resources into Rego
-- so those Kubernetes resources are visible to all policies. It also
lets you define policies inside Kubernetes' ConfigMap objects. You can
read more about it on <a href="https://github.com/open-policy-agent/kube-mgmt">its project
page</a>.</p>
<h3 id="gatekeeper"><a class="header" href="#gatekeeper">Gatekeeper</a></h3>
<p>Gatekeeper is very different from Open Policy Agent in this regard. It
is focused exclusively to be used in Kubernetes, and takes advantage
of that as much as it can, making some Kubernetes workflows easier
than Open Policy Agent in many cases.</p>
<h2 id="looking-at-the-differences"><a class="header" href="#looking-at-the-differences">Looking at the differences</a></h2>
<p>Both Open Policy Agent and Gatekeeper policies use Rego to describe
their policies as code. However, this is only one part of the
puzzle. Each solution has differences when it comes to writing real
policies in Rego, and we are going to look at those differences in the
next sections.</p>
<h2 id="entry-point"><a class="header" href="#entry-point">Entry point</a></h2>
<p>The entry point is the name of a rule within a package, and is the
rule to be invoked by the runtime when the policy is instantiated.</p>
<h2 id="current-limitations"><a class="header" href="#current-limitations">Current limitations</a></h2>
<h3 id="context-aware-policies-1"><a class="header" href="#context-aware-policies-1">Context-aware policies</a></h3>
<p>Context-aware policies are policies that don't evaluate the input
request in isolation. They take other factors into account in order to
take a decision. For example, a policy that evaluates namespaced
resources and uses an annotation on the parent namespace to configure
something on the policy. Another example would be a policy that
evaluates <code>Ingress</code> resources, but that in order to take a decision
has the list of the already existing <code>Ingress</code> resources.</p>
<p>The concept of context-aware policies can also extend to custom
resources, so your policy might want to evaluate a request based on
currently persisted custom resources as well.</p>
<p>Both Open Policy Agent and Gatekeeper support context-aware
policies. Right now Kubewarden implements this functionality only for
policies written with the Kubewarden SDK. We have plans to fill this
gap, to allow Rego policies to be context-aware policies too.</p>
<h3 id="mutating-policies-1"><a class="header" href="#mutating-policies-1">Mutating policies</a></h3>
<p>Gatekeeper has support for mutating policies, but Kubewarden has not
yet implemented mutating policies with Gatekeeper compatibility. You
can use policies that use the Kubewarden SDK to write mutating
policies, but at the time of writing, you cannot run Gatekeeper
mutating policies in Kubewarden yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-policy-agent-1"><a class="header" href="#open-policy-agent-1">Open Policy Agent</a></h1>
<blockquote>
<p><strong>Note well:</strong> Open Policy Agent support has been introduced starting from these releases:</p>
<ul>
<li>kwctl: v0.2.0</li>
<li>policy-server: v0.2.0</li>
</ul>
</blockquote>
<p>Open Policy Agent is a general purpose policy framework that uses the
Rego language to write policies.</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Rego policies work by receiving an input to evaluate, and produce an
output as a response. In this sense, Open Policy Agent has no specific
tooling for targeting writing policies for Kubernetes.</p>
<p>Specifically, policies in Open Policy Agent receive a JSON input and
produce a JSON output. When the Open Policy Agent server is set up to
receive admission review requests from Kubernetes, policies will
receive a Kubernetes <code>AdmissionReview</code> object in JSON format with the
object to evaluate, and they have to produce a valid <code>AdmissionReview</code>
object in return with the evaluation results.</p>
<h2 id="compatibility-with-existing-policies"><a class="header" href="#compatibility-with-existing-policies">Compatibility with existing policies</a></h2>
<p>All policies can be compiled to the <code>wasm</code> target (WebAssembly) with
the official <code>opa</code> CLI tool.</p>
<p>In terms of policy execution, you can read more about the <a href="writing-policies/rego/open-policy-agent/../02-builtin-support.html">Open Policy
Agent built-in support that is implemented in
Kubewarden</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-new-policy"><a class="header" href="#create-a-new-policy">Create a new policy</a></h1>
<p>Let's create a sample policy that will help us go through some
important concepts. Let's start!</p>
<blockquote>
<p><strong>Note well:</strong> we also provide a GitHub repository template
that you can use to quickly port an existing policy.</p>
<p>Check it out: <a href="https://github.com/kubewarden/opa-policy-template">kubewarden/opa-policy-template</a></p>
</blockquote>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>We will write, compile and execute the policy on this section. You
need some tools in order to complete this tutorial:</p>
<ul>
<li>
<p><a href="https://github.com/open-policy-agent/opa/releases"><code>opa</code></a>: we
will use the <code>opa</code> CLI to build our policy to a <code>wasm</code> target.</p>
</li>
<li>
<p><a href="https://github.com/kubewarden/kwctl/releases"><code>kwctl</code></a>: we will use
<code>kwctl</code> to execute our built policy.</p>
</li>
</ul>
<h2 id="the-policy"><a class="header" href="#the-policy">The policy</a></h2>
<p>We are going to create a policy that evaluates any kind of namespaced
resource. Its goal is to forbid the creation of any resource if the
target namespace is <code>default</code>. Otherwise, the request will be
accepted. Let's start by creating a folder called <code>opa-policy</code>.</p>
<p>We are going to create a folder named <code>data</code> inside of the
<code>opa-policy</code> folder. This folder will contain the recorded
<code>AdmissionReview</code> objects from the Kubernetes API server. I reduced
them greatly for the sake of simplicity for the exercise, so we can
focus on the bits that matter.</p>
<p>Let us first create a <code>default-ns.json</code> file with the following
contents inside the <code>data</code> directory:</p>
<pre><code class="language-json">{
  &quot;apiVersion&quot;: &quot;admission.k8s.io/v1&quot;,
  &quot;kind&quot;: &quot;AdmissionReview&quot;,
  &quot;request&quot;: {
    &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
    &quot;operation&quot;: &quot;CREATE&quot;,
    &quot;object&quot;: {
      &quot;kind&quot;: &quot;Pod&quot;,
      &quot;apiVersion&quot;: &quot;v1&quot;,
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;nginx&quot;,
        &quot;namespace&quot;: &quot;default&quot;,
        &quot;uid&quot;: &quot;04dc7a5e-e1f1-4e34-8d65-2c9337a43e64&quot;
      }
    }
  }
}
</code></pre>
<p>This simulates a pod operation creation inside the <code>default</code>
namespace. Now, let's create another request example in
<code>other-ns.json</code> inside the <code>data</code> directory:</p>
<pre><code class="language-json">{
  &quot;apiVersion&quot;: &quot;admission.k8s.io/v1&quot;,
  &quot;kind&quot;: &quot;AdmissionReview&quot;,
  &quot;request&quot;: {
    &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
    &quot;operation&quot;: &quot;CREATE&quot;,
    &quot;object&quot;: {
      &quot;kind&quot;: &quot;Pod&quot;,
      &quot;apiVersion&quot;: &quot;v1&quot;,
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;nginx&quot;,
        &quot;namespace&quot;: &quot;other&quot;,
        &quot;uid&quot;: &quot;04dc7a5e-e1f1-4e34-8d65-2c9337a43e64&quot;
      }
    }
  }
}
</code></pre>
<p>As you can see, this simulates another pod creation request, this time
under a namespace called <code>other</code>.</p>
<p>Let's go back to our <code>opa-policy</code> folder and start writing our Rego policy.</p>
<p>Inside this folder, we create a file named <code>request.rego</code> inside the
<code>opa-policy</code> folder. The name can be anything, but we'll use that one
for this exercise. As the name suggests, this is a Rego file that has
some utility code regarding the request/response itself: in
particular, it allows us to simplify our policy code itself and reuse
this common bit across different policies if desired. The contents
are:</p>
<pre><code class="language-rego">package policy

import data.kubernetes.admission

main = {
	&quot;apiVersion&quot;: &quot;admission.k8s.io/v1&quot;,
	&quot;kind&quot;: &quot;AdmissionReview&quot;,
	&quot;response&quot;: response,
}

response = {
	&quot;uid&quot;: input.request.uid,
	&quot;allowed&quot;: false,
	&quot;status&quot;: {&quot;message&quot;: reason},
} {
	reason = concat(&quot;, &quot;, admission.deny)
	reason != &quot;&quot;
} else = {
	&quot;uid&quot;: input.request.uid,
	&quot;allowed&quot;: true,
} {
	true
}
</code></pre>
<p>We will not go too deep into the Rego code itself. You can learn about
it in <a href="https://www.openpolicyagent.org/docs/latest/policy-language/">its
website</a>.</p>
<p>Suffice to say that in this case, it will return either <code>allowed: true</code> or <code>allowed: false</code> depending on whether other package
(<code>data.kubernetes.admission</code>) has any <code>deny</code> statement that evaluates
to <code>true</code>.</p>
<p>If any <code>data.kubernetes.admission.deny</code> evaluates to <code>true</code>, the
<code>response</code> here will evaluate to the first block. Otherwise, it will
evaluate to the second block -- leading to acceptance, because no
<code>deny</code> block evaluated to <code>true</code>, this means we are accepting the
request.</p>
<p>Now, this is just the shell of the policy, the utility. Now, we create
another file, called, for example <code>policy.rego</code> inside our
<code>opa-policy</code> folder with the following contents:</p>
<pre><code class="language-rego">package kubernetes.admission

deny[msg] {
	input.request.object.metadata.namespace == &quot;default&quot;
	msg := &quot;it is forbidden to use the default namespace&quot;
}
</code></pre>
<p>This is our policy. The important part. <code>deny</code> will evaluate to true
if all statements within it evaluate to true. In this case, is only
one statement: checking if the namespace is <code>default</code>.</p>
<p>By Open Policy Agent design, <code>input</code> contains the queriable object
with the <code>AdmissionReview</code> object, so we can inspect it quite easily.</p>
<p>If everything went well, our tree should look like the following:</p>
<pre><code>.
├── data
│   ├── default-ns.json
│   └── other-ns.json
├── policy.rego
└── request.rego

1 directory, 4 files
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-and-run"><a class="header" href="#build-and-run">Build and run</a></h1>
<p>In the previous section we have written our Rego policy. The structure
looks as the following:</p>
<pre><code>.
├── data
│   ├── default-ns.json
│   └── other-ns.json
├── policy.rego
└── request.rego

1 directory, 4 files
</code></pre>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<p>We have our policy, now let's go ahead and build it. We do:</p>
<pre><code class="language-shell">$ opa build -t wasm -e policy/main policy.rego request.rego
</code></pre>
<p>What this does is build the rego policy, with:</p>
<ul>
<li><code>target</code>: <code>wasm</code>. We want  to build the policy for the <code>wasm</code> target.</li>
<li><code>entrypoint</code>: <code>policy/main</code>. The entry point is the <code>main</code> rule
inside the <code>policy</code> package.</li>
<li><code>policy.rego</code>: build and include the <code>policy.rego</code> file.</li>
<li><code>request.rego</code>: build and include the <code>request.rego</code> file.</li>
</ul>
<p>After the build is complete, <code>opa build</code> will have generated a
<code>bundle.tar.gz</code> file. You can extract it:</p>
<pre><code class="language-shell">$ tar -xf bundle.tar.gz /policy.wasm
</code></pre>
<p>Now the tree looks like the following:</p>
<pre><code class="language-shell">.
├── bundle.tar.gz
├── data
│   ├── default-ns.json
│   └── other-ns.json
├── policy.rego
├── policy.wasm
└── request.rego

1 directory, 6 file
</code></pre>
<p>We have our precious <code>policy.wasm</code> file:</p>
<pre><code class="language-shell">$ file policy.wasm
policy.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
</code></pre>
<p>Now it's time to execute it! Let's go on.</p>
<h2 id="run"><a class="header" href="#run">Run</a></h2>
<p>We are going to use <code>kwctl</code> in order to run the policy:</p>
<pre><code>$ kwctl run -e opa --request-path data/other-ns.json policy.wasm | jq
{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: true
}
</code></pre>
<p>This request is accepted by the policy, since this is the request
pointing to the <code>other</code> namespace.</p>
<ul>
<li>
<p><code>execution-mode</code>: <code>opa</code>. Rego policies can be targeting Open Policy
Agent or Gatekeeper: we must tell <code>kwctl</code> what kind of policy we are
running.</p>
</li>
<li>
<p><code>request-path</code>: the location of the recorded request <code>kwctl</code> will
send to the policy to evaluate.</p>
</li>
</ul>
<p>Now let's try to evaluate the request that creates the pod inside the
<code>default</code> namespace:</p>
<pre><code>$ kwctl run -e opa --request-path data/default-ns.json policy.wasm | jq
{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: false,
  &quot;status&quot;: {
    &quot;message&quot;: &quot;it is forbidden to use the default namespace&quot;
  }
}
</code></pre>
<p>In this case, the policy is rejecting the request, and giving a reason
back to the API server that will be returned to the user or API consumer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distribute"><a class="header" href="#distribute">Distribute</a></h1>
<p>We have written, built and run our Rego policy. Now it's time to
distribute the policy.</p>
<p>Policies have to be annotated in order for them to be executed in the
<code>policy-server</code>, the component that executes the policies when running
in a Kubernetes cluster.</p>
<h2 id="annotating-the-policy"><a class="header" href="#annotating-the-policy">Annotating the policy</a></h2>
<p>Annotating a policy is a process that enriches the policy metadata
with relevant information like authorship, license, source code
location and other important metadata such as rules, that describes
what kind of resources this policy can understand and evaluate.</p>
<p>In order to annotate our policy let's write a simple <code>metadata.yaml</code>
file:</p>
<pre><code class="language-yaml">rules:
- apiGroups: [&quot;&quot;]
  apiVersions: [&quot;*&quot;]
  resources: [&quot;*&quot;]
  operations: [&quot;CREATE&quot;]
mutating: false
contextAware: false
executionMode: opa
annotations:
  io.kubewarden.policy.title: no-default-namespace
  io.kubewarden.policy.description: This policy will reject any resource created inside the default namespace
  io.kubewarden.policy.author: The Kubewarden Authors
  io.kubewarden.policy.url: https://github.com/kubewarden/some-policy
  io.kubewarden.policy.source: https://github.com/kubewarden/some-policy
  io.kubewarden.policy.license: Apache-2.0
  io.kubewarden.policy.usage: |
      This policy is just an example.

      You can write interesting descriptions about the policy here.
</code></pre>
<p>In this case, you can see several details:</p>
<ul>
<li>Rules: what resources this policy is targeting</li>
<li>Mutating: whether this policy is mutating. In this case, is just
validating.</li>
<li>Context aware: whether this policy requires context from the
cluster in order to evaluate the request.</li>
<li>Execution mode: since this is a Rego policy it is mandatory to
specify what execution mode it expects: <code>opa</code> or <code>gatekeeper</code>. This
policy is written in the <code>opa</code> style: returning a whole
<code>AdmissionReview</code> object.</li>
<li>Annotations: metadata stored into the policy itself.</li>
</ul>
<p>Let's go ahead and annotate our policy:</p>
<pre><code class="language-console">$ kwctl annotate policy.wasm --metadata-path metadata.yaml --output-path annotated-policy.wasm
</code></pre>
<p>Now you can <code>inspect</code> the policy if you will by running <code>kwctl inspect annotated-policy.wasm</code>.</p>
<h2 id="pushing-the-policy"><a class="header" href="#pushing-the-policy">Pushing the policy</a></h2>
<p>Now that the policy is annotated we can push it to an OCI
registry. Let's do that:</p>
<pre><code class="language-console">$ kwctl push annotated-policy.wasm registry.my-company.com/kubewarden/no-default-namespace:v0.0.1
Policy successfully pushed
</code></pre>
<p>Now our Rego policy targeting the OPA framework has everything it
needs to be deployed in production by creating a
<code>ClusterAdmissionPolicy</code>. Let's prepare that too. First, we have to
pull the policy into the <code>kwctl</code> local store:</p>
<pre><code class="language-console">$ kwctl pull registry://registry.my-company.com/kubewarden/no-default-namespace:v0.0.1
pulling policy...
</code></pre>
<p>Let's create a <code>ClusterAdmissionPolicy</code> out of it. This operation will
take into account the metadata it has about the policy:</p>
<pre><code class="language-console">$ kwctl manifest registry://registry.my-company.com/kubewarden/no-default-namespace:v0.0.1 --type ClusterAdmissionPolicy
---
apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: generated-policy
spec:
  module: &quot;registry://registry.my-company.com/kubewarden/no-default-namespace:v0.0.1&quot;
  settings: {}
  rules:
    - apiGroups:
        - &quot;&quot;
      apiVersions:
        - &quot;*&quot;
      resources:
        - &quot;*&quot;
      operations:
        - CREATE
  mutating: false
</code></pre>
<p>You can now use this <code>ClusterAdmissionPolicy</code> as a base to target the
resources that you want, or deploy to Kubernetes as is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gatekeeper-1"><a class="header" href="#gatekeeper-1">Gatekeeper</a></h1>
<blockquote>
<p><strong>Note well:</strong> Gatekeeper support has been introduced starting from these releases:</p>
<ul>
<li>kwctl: v0.2.0</li>
<li>policy-server: v0.2.0</li>
</ul>
</blockquote>
<p>Gatekeeper is a project targeting Kubernetes, and as such, has some
features that are thought out of the box for being integrated with it.</p>
<h2 id="compatibility-with-existing-policies-1"><a class="header" href="#compatibility-with-existing-policies-1">Compatibility with existing policies</a></h2>
<p>All the existing Gatekeeper policies should be compatible with
Kubewarden as we will explain during this chapter.</p>
<blockquote>
<p><strong>Note</strong>: if this is not the case, please report it to us and we
will do our best to make sure your policy runs flawlessly with
Kubewarden.</p>
</blockquote>
<p>Policies have to be compiled with the <code>opa</code> CLI to the <code>wasm</code> target.</p>
<p>In terms of policy execution, you can read more about the <a href="writing-policies/rego/gatekeeper/../02-builtin-support.html">Open Policy
Agent built-in support that is implemented in
Kubewarden</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-new-policy-1"><a class="header" href="#create-a-new-policy-1">Create a new policy</a></h1>
<p>Let's implement the same policy that <a href="writing-policies/rego/gatekeeper/../open-policy-agent/02-create-policy.html">we wrote with Open Policy
Agent</a>: a policy that
rejects a resource if it's targeting the <code>default</code> namespace.</p>
<blockquote>
<p><strong>Note well:</strong> we also provide a GitHub repository template
that you can use to quickly port an existing policy.</p>
<p>Check it out: <a href="https://github.com/kubewarden/gatekeeper-policy-template">kubewarden/gatekeeper-policy-template</a></p>
</blockquote>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<p>As in the previous section, we will require the following tools:</p>
<ul>
<li><code>opa</code></li>
<li><code>kwctl</code></li>
</ul>
<h2 id="the-policy-1"><a class="header" href="#the-policy-1">The policy</a></h2>
<p>Gatekeeper policies must return none or more violation objects. If no
violations are reported, the request will be accepted. If one, or more
violations are reported, the request will be rejected.</p>
<p>We create a new folder, named <code>rego-policy</code>. Inside of it, we create a
<code>policy.rego</code> file with contents:</p>
<pre><code class="language-rego">package policy

violation[{&quot;msg&quot;: msg}] {
        input.review.object.metadata.namespace == &quot;default&quot;
        msg := &quot;it is forbidden to use the default namespace&quot;
}
</code></pre>
<p>In this case, our entrypoint is <code>policy/violation</code>, and because of how
Rego works, the policy can have the following outcomes:</p>
<ul>
<li>
<p>return 1 violation: the object being reviewed is targeting the
default namespace.</p>
</li>
<li>
<p>return 0 violations: the object being reviewed is compliant with the
policy.</p>
</li>
</ul>
<p>Take a moment to compare this policy with the one we wrote in the Open
Policy Agent section. That one had to build the whole
<code>AdmissionReview</code> response, and the inputs were slightly
different. In the Gatekeeper mode, the <code>AdmissionRequest</code> object is
provided at the <code>input.review</code> attribute. All attributes of the
<code>AdmissionRequest</code> are readable along with <code>object</code>.</p>
<p>Now, let's create the requests that we are going to evaluate in the
next section.</p>
<p>Let us first create a <code>default-ns.json</code> file with the following
contents inside the <code>data</code> directory:</p>
<pre><code class="language-json">{
  &quot;apiVersion&quot;: &quot;admission.k8s.io/v1&quot;,
  &quot;kind&quot;: &quot;AdmissionReview&quot;,
  &quot;request&quot;: {
    &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
    &quot;operation&quot;: &quot;CREATE&quot;,
    &quot;object&quot;: {
      &quot;kind&quot;: &quot;Pod&quot;,
      &quot;apiVersion&quot;: &quot;v1&quot;,
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;nginx&quot;,
        &quot;namespace&quot;: &quot;default&quot;,
        &quot;uid&quot;: &quot;04dc7a5e-e1f1-4e34-8d65-2c9337a43e64&quot;
      }
    }
  }
}
</code></pre>
<p>Now, let's create another <code>AdmissionReview</code> object that this time is
targeting a namespace different than the <code>default</code> one. Let us name
this file <code>other-ns.json</code>. It has the following contents:</p>
<pre><code class="language-json">{
  &quot;apiVersion&quot;: &quot;admission.k8s.io/v1&quot;,
  &quot;kind&quot;: &quot;AdmissionReview&quot;,
  &quot;request&quot;: {
    &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
    &quot;operation&quot;: &quot;CREATE&quot;,
    &quot;object&quot;: {
      &quot;kind&quot;: &quot;Pod&quot;,
      &quot;apiVersion&quot;: &quot;v1&quot;,
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;nginx&quot;,
        &quot;namespace&quot;: &quot;other&quot;,
        &quot;uid&quot;: &quot;04dc7a5e-e1f1-4e34-8d65-2c9337a43e64&quot;
      }
    }
  }
}
</code></pre>
<p>As you can see, this simulates another pod creation request, this time
under a namespace called <code>other</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-and-run-1"><a class="header" href="#build-and-run-1">Build and run</a></h1>
<p>Building and running the policy is done exactly the same way as a Rego
policy targeting Open Policy Agent. The structure of our project is
like:</p>
<pre><code>.
├── data
│   ├── default-ns.json
│   └── other-ns.json
└── policy.rego

1 directory, 3 files
</code></pre>
<h2 id="build-1"><a class="header" href="#build-1">Build</a></h2>
<p>Let's build our policy by running the following <code>opa</code> command:</p>
<pre><code class="language-shell">$ opa build -t wasm -e policy/violation policy.rego
</code></pre>
<p>What this does is build the rego policy, with:</p>
<ul>
<li><code>target</code>: <code>wasm</code>. We want  to build the policy for the <code>wasm</code> target.</li>
<li><code>entrypoint</code>: <code>policy/violation</code>. The entry point is the <code>violation</code>
rule inside the <code>policy</code> package.</li>
<li><code>policy.rego</code>: build and include the <code>policy.rego</code> file.</li>
</ul>
<p>The previous command generates a <code>bundle.tar.gz</code> file. You can extract
the wasm module from it:</p>
<pre><code class="language-shell">$ tar -xf bundle.tar.gz /policy.wasm
</code></pre>
<p>The project tree looks like the following:</p>
<pre><code>.
├── bundle.tar.gz
├── data
│   ├── default-ns.json
│   └── other-ns.json
├── policy.rego
└── policy.wasm

1 directory, 5 files
</code></pre>
<p>We can now execute our policy!</p>
<h2 id="run-1"><a class="header" href="#run-1">Run</a></h2>
<p>Let's use <code>kwctl</code> to run our policy as follows:</p>
<pre><code>$ kwctl run -e gatekeeper --request-path data/other-ns.json policy.wasm | jq
{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: true
}
</code></pre>
<p>Given that this is our resource created in the namespace called
<code>other</code>, this resource is accepted, as expected.</p>
<p>Now let's execute a request that will be rejected by the policy:</p>
<pre><code>$ kwctl run -e gatekeeper --request-path data/default-ns.json policy.wasm | jq
{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: false,
  &quot;status&quot;: {
    &quot;message&quot;: &quot;it is forbidden to use the default namespace&quot;
  }
}
</code></pre>
<p>As you can see, our Gatekeeper policy rejected this resource as expected.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distribute-1"><a class="header" href="#distribute-1">Distribute</a></h1>
<p>Policies have to be annotated for them to be pushed, and eventually
executed by the Kubewarden <code>policy-server</code> in a Kubernetes cluster.</p>
<p>Annotating and distributing our Gatekeeper policy is very similar to
distributing an Open Policy Agent one. Let's go through it.</p>
<h2 id="annotating-the-policy-1"><a class="header" href="#annotating-the-policy-1">Annotating the policy</a></h2>
<p>We are going to write a <code>metadata.yaml</code> file in our policy directory
with contents:</p>
<pre><code class="language-yaml">rules:
- apiGroups: [&quot;&quot;]
  apiVersions: [&quot;*&quot;]
  resources: [&quot;*&quot;]
  operations: [&quot;CREATE&quot;]
mutating: false
contextAware: false
executionMode: gatekeeper
annotations:
  io.kubewarden.policy.title: no-default-namespace
  io.kubewarden.policy.description: This policy will reject any resource created inside the default namespace
  io.kubewarden.policy.author: The Kubewarden Authors
  io.kubewarden.policy.url: https://github.com/kubewarden/some-policy
  io.kubewarden.policy.source: https://github.com/kubewarden/some-policy
  io.kubewarden.policy.license: Apache-2.0
  io.kubewarden.policy.usage: |
      This policy is just an example.

      You can write interesting descriptions about the policy here.
</code></pre>
<p>As you can see, everything is the same as the Open Policy Agent
version metadata, except for the <code>executionMode: gatekeeper</code> bit.</p>
<p>Let's go ahead and annotate the policy:</p>
<pre><code class="language-console">$ kwctl annotate policy.wasm --metadata-path metadata.yaml --output-path annotated-policy.wasm
</code></pre>
<h2 id="pushing-the-policy-1"><a class="header" href="#pushing-the-policy-1">Pushing the policy</a></h2>
<p>Let's push our policy to an OCI registry:</p>
<pre><code class="language-console">$ kwctl push annotated-policy.wasm registry.my-company.com/kubewarden/no-default-namespace-gatekeeper:v0.0.1
Policy successfully pushed
</code></pre>
<h2 id="deploying-on-kubernetes"><a class="header" href="#deploying-on-kubernetes">Deploying on Kubernetes</a></h2>
<p>We have to pull our policy to our <code>kwctl</code> local store first:</p>
<pre><code class="language-console">$ kwctl pull registry://registry.my-company.com/kubewarden/no-default-namespace-gatekeeper:v0.0.1
pulling policy...
</code></pre>
<p>We can now create a scaffold <code>ClusterAdmissionPolicy</code> resource:</p>
<pre><code class="language-console">$ kwctl manifest registry://registry.my-company.com/kubewarden/no-default-namespace-gatekeeper:v0.0.1 --type ClusterAdmissionPolicy
---
apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: generated-policy
spec:
  module: &quot;registry://registry.my-company.com/kubewarden/no-default-namespace-gatekeeper:v0.0.1&quot;
  settings: {}
  rules:
    - apiGroups:
        - &quot;&quot;
      apiVersions:
        - &quot;*&quot;
      resources:
        - &quot;*&quot;
      operations:
        - CREATE
  mutating: false
</code></pre>
<p>We could now use this <code>ClusterAdmissionPolicy</code> resource to deploy our
policy to a Kubernetes cluster.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-support"><a class="header" href="#builtin-support">Builtin support</a></h1>
<p>Building a policy for the <code>wasm</code> target is only half of the problem,
it needs to be executed.</p>
<p>The Open Policy Agent team has a dedicated page you can check in order
to <a href="https://www.openpolicyagent.org/docs/latest/policy-reference/#built-in-functions">find out the built-in support
level</a>.</p>
<p>When building a Rego policy into a WebAssembly module, some of these
built-in functions are going to be implemented inside of the Wasm file
itself (the built-ins marked with a green check in the previously
linked table) -- regardless of the runtime; while others have to be
provided at execution time by the WebAssembly runtime evaluating the
module.</p>
<p>The built-ins marked as <code>SDK-dependent</code> are the ones that the host has
to implement -- in this case, Kubewarden. Open Policy Agent and
Gatekeeper may use them depending on the needs of the policy. In any
case, this built-ins are exposed to the policy and any new or existing
policy could depend on them.</p>
<p>There are still some built-ins that are not yet provided by us,
however, based on the policies we have seen in the open, the ones we
already support should be enough for the majority of Kubernetes users.</p>
<p><a href="https://github.com/kubewarden/policy-evaluator/issues/56">This GitHub issue</a>
keeps track of the Rego built-ins we have still to implement. Feel free to
comment over there to prioritize our work.</p>
<h2 id="executing-policies-with-missing-built-ins"><a class="header" href="#executing-policies-with-missing-built-ins">Executing policies with missing built-ins</a></h2>
<p>When a policy is instantiated with <code>kwctl</code> or with <code>policy-server</code>,
the list of built-ins used by the policy will be inspected, and if any
of the used built-ins is missing, the program will abort execution
logging a fatal error reporting what are the missing built-ins.</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p><strong>Note well:</strong> Go's support for WebAssembly is fast evolving. The contents
of this page have been written during April 2021, hence they could be outdated.</p>
</blockquote>
<h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>Currently the official Go compiler cannot produce WebAssembly binaries
that can be run <strong>outside</strong> of the browser.
<a href="https://github.com/golang/go/issues/31105">This upstream issue</a> is tracking
the evolution of this topic.
Due to that, it's not possible to use the Go compiler to write Kubewarden policies.</p>
<p>Luckily there's another Go compiler that is capable of building WebAssembly
binaries that can be used by Kubewarden. This compiler is called <a href="https://tinygo.org/">TinyGo</a>:</p>
<blockquote>
<p>TinyGo is a project to bring the Go programming language to microcontrollers
and modern web browsers by creating a new compiler based on LLVM.</p>
<p>You can compile and run TinyGo programs on many different microcontroller
boards such as the BBC micro:bit and the Arduino Uno.</p>
<p>TinyGo can also be used to produce WebAssembly (Wasm) code which is very
compact in size.</p>
</blockquote>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>TinyGo doesn't yet support all the Go features (see <a href="https://tinygo.org/lang-support/">here</a>
to see the current project status). Currently its biggest limitation
is the lack of a fully supported <code>reflect</code> package. That leads to the inability to use
the <code>encoding/json</code> package against structures and user defined types.</p>
<p>Kubewarden policies need to process JSON data like the policy settings and
the actual request received by Kubernetes.</p>
<p>Despite TinyGo's current limitations, it's still easy and doable to write
Kubewarden validation policies with it.</p>
<blockquote>
<p><strong>Note well:</strong> unfortunately, it's currently impossible to write mutating
policies using TinyGo.</p>
</blockquote>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<p>Writing Kubewarden policies requires a version of TinyGo greater than <code>0.17.0</code>.</p>
<p>These Go libraries are extremely useful when writing a Kubewarden policy:</p>
<ul>
<li><a href="https://github.com/kubewarden/policy-sdk-go">Kubewarden Go SDK</a>: provides a series of
structures and functions that reduce the amount of code to write. It also provides test helpers.</li>
<li><a href="https://github.com/tidwall/gjson">gjson</a>: provides a powerful query language that allows
quick navigation of JSON documents and data retrieval. This library doesn't use the
<code>encoding/json</code> package provided by Go's stdlib, hence it's usable with TinyGo.</li>
<li><a href="https://github.com/deckarep/golang-set">mapset</a>: provides a Go implementation of the
<a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a>
data structure. This library significantly reduces the amount of code to be written,
that's because operations like Set <code>union</code>, <code>intersection</code>, <code>difference</code> are pretty frequent inside
of policies.</li>
</ul>
<p>Last but not least, the Kubewarden project provides a
<a href="https://github.com/kubewarden/go-policy-template">template Go policy project</a>
that can be used to quickly create Kubewarden policies written in Go.</p>
<h2 id="getting-tinygo-dependencies"><a class="header" href="#getting-tinygo-dependencies">Getting TinyGo dependencies</a></h2>
<p>The easiest way to get TinyGo is by using the upstream container images.
Official releases can be found <a href="https://hub.docker.com/r/tinygo/tinygo">here</a>, while
builds from the development branch are automatically pushed
<a href="https://hub.docker.com/r/tinygo/tinygo-dev">here</a>.</p>
<p>If needed, checkout TinyGo's <a href="https://tinygo.org/getting-started/">getting started</a> page for
more information.</p>
<blockquote>
<p><strong>Note well:</strong> Kubewarden's requires code that is available only on the development branch. This will
be solved once TinyGo <code>0.17.0</code> is released. In the meantime we will use the container image
based on the development branch: <code>tinygo/tinygo-dev:latest</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-validation-policy-1"><a class="header" href="#creating-a-new-validation-policy-1">Creating a new validation policy</a></h1>
<p>We are going to create a validation policy that validates the labels of generic Kubernetes
objects.</p>
<p>The policy will reject all the resources that use one or more labels on the deny list.
The policy will also validate certain labels using a regular expression 
provided by the user.</p>
<p>To summarize, the policy settings will look like that:</p>
<pre><code class="language-yaml"># List of labels that cannot be used
denied_labels:
- foo
- bar

# Labels that are validated with user-defined regular expressions
constrained_labels:
  priority: &quot;[123]&quot;
  cost-center: &quot;^cc-\d+&quot;
</code></pre>
<p>The policy would reject the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    foo: hello world
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>The policy would also reject the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    cost-center: cc-marketing
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>Policy's settings can also be used to force certain labels to be specified,
regardless of their contents:</p>
<pre><code class="language-yaml"># Policy's settings

constrained_labels:
  mandatory-label: &quot;.*&quot; # &lt;- this label must be present, we don't care about its value
</code></pre>
<h2 id="scaffolding-new-policy-project-1"><a class="header" href="#scaffolding-new-policy-project-1">Scaffolding new policy project</a></h2>
<p>The creation of a new policy project can be done by using this GitHub
template repository: <a href="https://github.com/kubewarden/go-policy-template">kubewarden/go-policy-template</a>.
Just press the &quot;Use  this template&quot; green button near the top of the page
and follow GitHub's wizard.</p>
<p>Clone the repository locally and then ensure the <code>module</code> directive inside
of the <code>go.mod</code> file looks like that:</p>
<pre><code class="language-go">module &lt;path to your repository&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-policy-settings-1"><a class="header" href="#defining-policy-settings-1">Defining policy settings</a></h1>
<p>As a first step we will define the structure that holds the policy settings.</p>
<p>We will do that by adding this code inside of the <code>settings.go</code> file:</p>
<pre><code class="language-go">import (
	&quot;github.com/deckarep/golang-set&quot;
	&quot;github.com/kubewarden/gjson&quot;
	kubewarden &quot;github.com/kubewarden/policy-sdk-go&quot;

	&quot;fmt&quot;
	&quot;regexp&quot;
)

type Settings struct {
	DeniedLabels      mapset.Set                    `json:&quot;denied_labels&quot;`
	ConstrainedLabels map[string]*RegularExpression `json:&quot;constrained_labels&quot;`
}
</code></pre>
<p>As you can see we're using the <code>regexp</code> package to handle regular expression objects, plus
we use the <code>mapset.Set</code> structure to store the list of denied labels.</p>
<p>The <code>Settings</code> struct has json attributes, we will use them later when writing
our unit tests. The unit tests are going to be executed using Go official compiler, hence
we will be able to leverage the <code>encoding/json</code> package.</p>
<p>The <code>Settings</code> class is not using the official <code>regexp.RegExp</code> object to
represent regular expressions. That's because the <code>regexp.RegExp</code> struct doesn't
handle serialization and deserialization to JSON.</p>
<p>This is the implementation of the <code>RegularExpression</code> struct:</p>
<pre><code class="language-go">// A wrapper around the standard regexp.Regexp struct
// that implements marshalling and unmarshalling
type RegularExpression struct {
	*regexp.Regexp
}

// Convenience method to build a regular expression
func CompileRegularExpression(expr string) (*RegularExpression, error) {
	nativeRegExp, err := regexp.Compile(expr)
	if err != nil {
		return nil, err
	}
	return &amp;RegularExpression{nativeRegExp}, nil
}

// UnmarshalText satisfies the encoding.TextMarshaler interface,
// also used by json.Unmarshal.
func (r *RegularExpression) UnmarshalText(text []byte) error {
	nativeRegExp, err := regexp.Compile(string(text))
	if err != nil {
		return err
	}
	r.Regexp = nativeRegExp
	return nil
}

// MarshalText satisfies the encoding.TextMarshaler interface,
// also used by json.Marshal.
func (r *RegularExpression) MarshalText() ([]byte, error) {
	if r.Regexp != nil {
		return []byte(r.Regexp.String()), nil
	}

	return nil, nil
}
</code></pre>
<h2 id="building-settings-instances"><a class="header" href="#building-settings-instances">Building <code>Settings</code> instances</a></h2>
<p>At runtime we can't rely on the automatic struct marshalling and unmarshalling
provided by the <code>encoding/json</code> package due to TinyGo current limitations.
Because of that we will create two initialization helpers:</p>
<ul>
<li><code>NewSettingsFromValidationReq</code>: this is used when building a <code>Settings</code>
instance starting from a <a href="writing-policies/go//writing-policies/index.html#the-validationrequest-object"><code>ValidationRequest</code></a>
object</li>
<li><code>NewSettingsFromValidateSettingsPayload</code>: this is used when building a
<code>Settings</code> instance inside of the <a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point"><code>validate_settings</code></a> entry point. This entry point receives the &quot;naked&quot; Settings JSON
dictionary</li>
</ul>
<p>This is the implementation of these functions:</p>
<pre><code class="language-go">// Builds a new Settings instance starting from a validation
// request payload:
// {
//    &quot;request&quot;: ...,
//    &quot;settings&quot;: {
//       &quot;denied_labels&quot;: [...],
//       &quot;constrained_labels&quot;: { ... }
//    }
// }
func NewSettingsFromValidationReq(payload []byte) (Settings, error) {
	// Note well: we don't validate the input JSON now, this has
	// already done inside of the `validate` function

	return newSettings(
		payload,
		&quot;settings.denied_labels&quot;,
		&quot;settings.constrained_labels&quot;)
}

// Builds a new Settings instance starting from a Settings
// payload:
// {
//    &quot;denied_names&quot;: [ ... ],
//    &quot;constrained_labels&quot;: { ... }
// }
func NewSettingsFromValidateSettingsPayload(payload []byte) (Settings, error) {
	if !gjson.ValidBytes(payload) {
		return Settings{}, fmt.Errorf(&quot;denied JSON payload&quot;)
	}

	return newSettings(
		payload,
		&quot;denied_labels&quot;,
		&quot;constrained_labels&quot;)
}
</code></pre>
<p>The heavy lifting of the setting is done inside of the <code>newSettings</code> function, which
is invoked by both <code>NewSettingsFromValidateSettingsPayload</code> and <code>NewSettingsFromValidationReq</code>.</p>
<p>The function takes the raw JSON payload and a list of <a href="https://github.com/tidwall/gjson">gjson</a>
queries. These queries are used to extract the values from the JSON data and
build the actual object:</p>
<pre><code class="language-go">func newSettings(payload []byte, paths ...string) (Settings, error) {
	if len(paths) != 2 {
		return Settings{}, fmt.Errorf(&quot;wrong number of json paths&quot;)
	}

	data := gjson.GetManyBytes(payload, paths...)

	deniedLabels := mapset.NewThreadUnsafeSet()
	data[0].ForEach(func(_, entry gjson.Result) bool {
		deniedLabels.Add(entry.String())
		return true
	})

	constrainedLabels := make(map[string]*RegularExpression)
	var err error
	data[1].ForEach(func(key, value gjson.Result) bool {
		var regExp *RegularExpression
		regExp, err = CompileRegularExpression(value.String())
		if err != nil {
			return false
		}

		constrainedLabels[key.String()] = regExp
		return true
	})
	if err != nil {
		return Settings{}, err
	}

	return Settings{
		DeniedLabels:      deniedLabels,
		ConstrainedLabels: constrainedLabels,
	}, nil
}
</code></pre>
<p>As you can see the code above is pretty straightforward. The <code>gjson</code> package
provides a convenient method to fetch multiple values from the JSON data.</p>
<p>The <code>newSettings</code> function also creates instances of <code>regexp.Regexp</code> objects
and ensures the regular expressions provided by the user are correct.</p>
<blockquote>
<p><strong>Note well:</strong> all the <code>mapset.Set</code> objects are deliberately created using
their <a href="https://pkg.go.dev/github.com/deckarep/golang-set?utm_source=godoc#NewThreadUnsafeSet">thread-unsafe variant</a>.
The WebAssembly code is executed in single thread, hence there are no
concurrency issues.</p>
<p>Moreover, the WebAssembly standard doesn't cover
threads yet. See <a href="https://github.com/WebAssembly/threads">the official proposal</a>
for more details.</p>
</blockquote>
<h2 id="implementing-settings-validation"><a class="header" href="#implementing-settings-validation">Implementing <code>Settings</code> validation</a></h2>
<p>All Kubewarden policies have to implement
<a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point">settings validation</a>.</p>
<p>This can be easily done by adding a <code>Valid</code> method to the <code>Settings</code> instances:</p>
<pre><code class="language-go">func (s *Settings) Valid() (bool, error) {
	constrainedLabels := mapset.NewThreadUnsafeSet()

	for label := range s.ConstrainedLabels {
		constrainedLabels.Add(label)
	}

	constrainedAndDenied := constrainedLabels.Intersect(s.DeniedLabels)
	if constrainedAndDenied.Cardinality() != 0 {
		return false,
			fmt.Errorf(&quot;These labels cannot be constrained and denied at the same time: %v&quot;, constrainedAndDenied)
	}

	return true, nil
}
</code></pre>
<p>The <code>Valid</code> method ensures no &quot;denied&quot; label is also part of the &quot;constrained&quot; map. The check
is simplified by the usage of the <code>Intersect</code> method provided by <code>mapset.Set</code>.</p>
<blockquote>
<p><strong>Note well:</strong> the <code>Valid</code> method is invoked against an already instantiated <code>Setting</code> object. That means
the validation of the regular expression provided by the user already took place at
inside of the <code>Settings</code> constructor.</p>
</blockquote>
<p>Finally, we have to ensure the <code>validateSettings</code> function that was automatically generated
is changed to look like that:</p>
<pre><code class="language-go">func validateSettings(payload []byte) ([]byte, error) {
	settings, err := NewSettingsFromValidateSettingsPayload(payload)
	if err != nil {
		// this happens when one of the user-defined regular expressions are invalid
		return kubewarden.RejectSettings(
			kubewarden.Message(fmt.Sprintf(&quot;Provided settings are not valid: %v&quot;, err)))
	}

	valid, err := settings.Valid()
	if valid {
		return kubewarden.AcceptSettings()
	}
	return kubewarden.RejectSettings(
		kubewarden.Message(fmt.Sprintf(&quot;Provided settings are not valid: %v&quot;, err)))
}
</code></pre>
<p>As you can see, the function takes advantage of the helper functions provided
by <a href="https://github.com/kubewarden/policy-sdk-go">Kubewarden's SDK</a>.</p>
<h2 id="testing-the-settings-code"><a class="header" href="#testing-the-settings-code">Testing the settings code</a></h2>
<p>As always, it's important to have good test coverage of the code we write.
The code we generated comes with a series of unit test defined inside of
the <code>settings_test.go</code> file.</p>
<p>We will have to change the contents of this file to reflect the new behaviour of the
<code>Settings</code> class.</p>
<p>We will start by including the Go packages we will use:</p>
<pre><code class="language-go">import (
	&quot;encoding/json&quot;
	&quot;testing&quot;

	kubewarden_testing &quot;github.com/kubewarden/policy-sdk-go/testing&quot;
)
</code></pre>
<p>As stated before, the unit tests are not part of the final WebAssembly binary, hence
we can build them using the official Go compiler. That means we can use the <code>encoding/json</code>
package to simplify our tests.</p>
<p>We will start by writing a unit test that ensures we can allocate a <code>Settings</code>
instance from a <a href="writing-policies/go//writing-policies/index.html#the-validationrequest-object"><code>ValidationRequest</code></a>
object:</p>
<pre><code class="language-go">func TestParseValidSettings(t *testing.T) {
	request := `
	{
		&quot;request&quot;: &quot;doesn't matter here&quot;,
		&quot;settings&quot;: {
			&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
			&quot;constrained_labels&quot;: {
				&quot;cost-center&quot;: &quot;cc-\\d+&quot;
			}
		}
	}
	`
	rawRequest := []byte(request)

	settings, err := NewSettingsFromValidationReq(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	expected_denied_labels := []string{&quot;foo&quot;, &quot;bar&quot;}
	for _, exp := range expected_denied_labels {
		if !settings.DeniedLabels.Contains(exp) {
			t.Errorf(&quot;Missing value %s&quot;, exp)
		}
	}

	re, found := settings.ConstrainedLabels[&quot;cost-center&quot;]
	if !found {
		t.Error(&quot;Didn't find the expected constrained label&quot;)
	}

	expected_regexp := `cc-\d+`
	if re.String() != expected_regexp {
		t.Errorf(&quot;Expected regexp to be %v - got %v instead&quot;,
			expected_regexp, re.String())
	}
}
</code></pre>
<p>Next we will define a test that ensures a <code>Settings</code> instance
cannot be generated when the user provides a broken regular
expression:</p>
<pre><code class="language-go">func TestParseSettingsWithInvalidRegexp(t *testing.T) {
	request := `
	{
		&quot;request&quot;: &quot;doesn't matter here&quot;,
		&quot;settings&quot;: {
			&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
			&quot;constrained_labels&quot;: {
				&quot;cost-center&quot;: &quot;cc-[a+&quot;
			}
		}
	}
	`
	rawRequest := []byte(request)

	_, err := NewSettingsFromValidationReq(rawRequest)
	if err == nil {
		t.Errorf(&quot;Didn'g get expected error&quot;)
	}
}
</code></pre>
<p>Next we will define a test that checks the behaviour
of the <a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point"><code>validate_settings</code></a>
entry-point.</p>
<p>In this case we actually look at the <code>SettingsValidationResponse</code> object
returned by our <code>validateSettings</code> function:</p>
<pre><code class="language-go">func TestDetectValidSettings(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;cc-\\d+&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if !response.Valid {
		t.Errorf(&quot;Expected settings to be valid: %s&quot;, response.Message)
	}
}
</code></pre>
<p>Finally, we write two more tests to ensure the <code>validateSettings</code> function
rejects invalid settings with the right messages:</p>
<pre><code class="language-go">func TestDetectNotValidSettingsDueToBrokenRegexp(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;cc-[a+&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Valid {
		t.Error(&quot;Expected settings to not be valid&quot;)
	}

	if response.Message != &quot;Provided settings are not valid: error parsing regexp: missing closing ]: `[a+`&quot; {
		t.Errorf(&quot;Unexpected validation error message: %s&quot;, response.Message)
	}
}

func TestDetectNotValidSettingsDueToConflictingLabels(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot;, &quot;cost-center&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;.*&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Valid {
		t.Error(&quot;Expected settings to not be valid&quot;)
	}

	if response.Message != &quot;Provided settings are not valid: These labels cannot be constrained and denied at the same time: Set{cost-center}&quot; {
		t.Errorf(&quot;Unexpected validation error message: %s&quot;, response.Message)
	}
}
</code></pre>
<p>Now we can run the test by using the following command:</p>
<pre><code class="language-shell">go test -v settings.go settings_test.go
</code></pre>
<p>All the tests will pass with the following output:</p>
<pre><code class="language-shell">=== RUN   TestParseValidSettings
--- PASS: TestParseValidSettings (0.00s)
=== RUN   TestParseSettingsWithInvalidRegexp
--- PASS: TestParseSettingsWithInvalidRegexp (0.00s)
=== RUN   TestDetectValidSettings
--- PASS: TestDetectValidSettings (0.00s)
=== RUN   TestDetectNotValidSettingsDueToBrokenRegexp
--- PASS: TestDetectNotValidSettingsDueToBrokenRegexp (0.00s)
=== RUN   TestDetectNotValidSettingsDueToConflictingLabels
--- PASS: TestDetectNotValidSettingsDueToConflictingLabels (0.00s)
PASS
ok  	command-line-arguments	0.001s
</code></pre>
<p>We can now move to implement the actual validation code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-validation-logic-1"><a class="header" href="#writing-the-validation-logic-1">Writing the validation logic</a></h1>
<p>It's now time to write the actual validation logic. This is done
inside of the <code>validate.go</code> file.</p>
<p>The scaffolded policy has already a <code>validate</code> function, we will need to make
very few changes to it.</p>
<p>This is how the function has to look like:</p>
<pre><code class="language-go">func validate(payload []byte) ([]byte, error) {
	// NOTE 1
	if !gjson.ValidBytes(payload) {
		return kubewarden.RejectRequest(
			kubewarden.Message(&quot;Not a valid JSON document&quot;),
			kubewarden.Code(400))
	}

	// NOTE 2
	settings, err := NewSettingsFromValidationReq(payload)
	if err != nil {
		return kubewarden.RejectRequest(
			kubewarden.Message(err.Error()),
			kubewarden.Code(400))
	}

	// NOTE 3
	data := gjson.GetBytes(
		payload,
		&quot;request.object.metadata.labels&quot;)

	// NOTE 4
	data.ForEach(func(key, value gjson.Result) bool {
		label := key.String()

		// NOTE 5
		if settings.DeniedLabels.Contains(label) {
			err = fmt.Errorf(&quot;Label %s is on the deny list&quot;, label)
			// stop iterating over labels
			return false
		}

		// NOTE 6
		regExp, found := settings.ConstrainedLabels[label]
		if found {
			// This is a constrained label
			if !regExp.Match([]byte(value.String())) {
				err = fmt.Errorf(&quot;The value of %s doesn't pass user-defined constraint&quot;, label)
				// stop iterating over labels
				return false
			}
		}

		return true
	})

	// NOTE 7
	if err != nil {
		return kubewarden.RejectRequest(
			kubewarden.Message(err.Error()),
			kubewarden.NoCode)
	}

	return kubewarden.AcceptRequest()
}
</code></pre>
<p>The code has some <code>NOTE</code> sections inside of it. Let's get through them:</p>
<ol>
<li>The function ensures the JSON payload is properly formatted. This
is done using a function provided by the <code>gjson</code> library</li>
<li>The <code>Settings</code> instance is created using one of the constructor
methods we defined inside of <code>settings.go</code></li>
<li>We use a <code>gjson</code> selector to get the <code>label</code> map provided by the object
embedded into the request</li>
<li>We use a <code>gjson</code> helper to iterate over the results of the query. If the query
has no results the loop will never take place.</li>
<li>We look for the <code>label</code> of the object inside of the list of denied labels
provided by the user via the policy settings. If the <code>label</code> is a denied
one, we set the value of the <code>err</code> variable and exit from the loop (that
happens by returning <code>false</code> instead of <code>true</code>).</li>
<li>We look for the <code>label</code> of the object inside of the list of constrained labels
provided by the user via the policy settings. When we have a match we use
the regular expression provided by the user to validate the value of the label.
If the validation fails, we set the value of the <code>err</code> variable and exit
from the loop (that happens by returning <code>false</code> instead of <code>true</code>).</li>
<li>If the <code>err</code> variable is not <code>nil</code>, we use the helper provided by Kubewarden's
SDK to reject the request. Otherwise we accept it.</li>
</ol>
<h2 id="testing-the-validation-code"><a class="header" href="#testing-the-validation-code">Testing the validation code</a></h2>
<p>It's now time to write some unit tests to ensure the validation code is behaving
properly. These tests are going to be located inside of the <code>validate_test.go</code>
file.</p>
<p>The tests will rely on some <a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a>
located inside of the <code>test_data</code> directory. This directory has already
been populated by the template repository with an example
<code>admissionreview.request</code> object that matches this tutorial, but you would need
to craft one with the correct Kubernetes object you are writing the policy for,
as we covered in <a href="writing-policies/go//writing-policies/spec/03-validating-policies.html">&quot;validating
policies&quot;</a></p>
<p>We will start by including the following packages:</p>
<pre><code class="language-go">import (
	&quot;encoding/json&quot;
	&quot;testing&quot;

	&quot;github.com/deckarep/golang-set&quot;
	kubewarden_testing &quot;github.com/kubewarden/policy-sdk-go/testing&quot;
)
</code></pre>
<p>The first unit test will ensure that having no user settings leads
to the request to be accepted:</p>
<pre><code class="language-go">func TestEmptySettingsLeadsToRequestAccepted(t *testing.T) {
	settings := Settings{}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>As you can see we are using some test helper functions and structures provided
by the Kubewarden SDK.</p>
<p>The next test ensures a request can be accepted when none of its labels
is relevant to the user:</p>
<pre><code class="language-go">func TestRequestAccepted(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^world-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;hello&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;bad1&quot;, &quot;bad2&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>Next we will ensure a request is accepted when one of its labels satisfies
the constraint provided by the user:</p>
<pre><code class="language-go">func TestAcceptRequestWithConstraintLabel(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^team-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %s&quot;, err)
	}
	constrainedLabels[&quot;owner&quot;] = re
	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;bad1&quot;, &quot;bad2&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>It's now time to test the rejection of requests.</p>
<p>This test verifies a request is rejected when one of the labels is
on the deny list:</p>
<pre><code class="language-go">func TestRejectionBecauseDeniedLabel(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^world-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;hello&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;owner&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != false {
		t.Error(&quot;Unexpected accept response&quot;)
	}

	expected_message := &quot;Label owner is on the deny list&quot;
	if response.Message != expected_message {
		t.Errorf(&quot;Got '%s' instead of '%s'&quot;, response.Message, expected_message)
	}
}
</code></pre>
<p>The next test ensures a request is rejected when one of the user defined
constraints is not satisfied:</p>
<pre><code class="language-go">func TestRejectionBecauseConstrainedLabelNotValid(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^cc-\d+$`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;cc-center&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != false {
		t.Error(&quot;Unexpected accept response&quot;)
	}

	expected_message := &quot;The value of cc-center doesn't pass user-defined constraint&quot;
	if response.Message != expected_message {
		t.Errorf(&quot;Got '%s' instead of '%s'&quot;, response.Message, expected_message)
	}
}
</code></pre>
<p>We can now run all the unit tests, including the one defined inside of <code>settings_test.go</code>,
by using this simple command:</p>
<pre><code class="language-shell">make test
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-shell">go test -v
=== RUN   TestParseValidSettings
--- PASS: TestParseValidSettings (0.00s)
=== RUN   TestParseSettingsWithInvalidRegexp
--- PASS: TestParseSettingsWithInvalidRegexp (0.00s)
=== RUN   TestDetectValidSettings
--- PASS: TestDetectValidSettings (0.00s)
=== RUN   TestDetectNotValidSettingsDueToBrokenRegexp
--- PASS: TestDetectNotValidSettingsDueToBrokenRegexp (0.00s)
=== RUN   TestDetectNotValidSettingsDueToConflictingLabels
--- PASS: TestDetectNotValidSettingsDueToConflictingLabels (0.00s)
=== RUN   TestEmptySettingsLeadsToRequestAccepted
--- PASS: TestEmptySettingsLeadsToRequestAccepted (0.00s)
=== RUN   TestRequestAccepted
--- PASS: TestRequestAccepted (0.00s)
=== RUN   TestAcceptRequestWithConstraintLabel
--- PASS: TestAcceptRequestWithConstraintLabel (0.00s)
=== RUN   TestRejectionBecauseDeniedLabel
--- PASS: TestRejectionBecauseDeniedLabel (0.00s)
=== RUN   TestRejectionBecauseConstrainedLabelNotValid
--- PASS: TestRejectionBecauseConstrainedLabelNotValid (0.00s)
PASS
ok  	github.com/kubewarden/safe-labels-policy	0.001s
</code></pre>
<p>We can now move to the next step, write some end-to-end tests.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="end-to-end-testing"><a class="header" href="#end-to-end-testing">End-to-end testing</a></h1>
<p>So far we have tested the policy using a set of Go unit tests. This section shows
how we can write end-to-end test that run tests against the actual WebAssembly
binary produced by TinyGo.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>These tools need to be installed on your development machine:</p>
<ul>
<li>docker or another container engine: used to build the WebAssembly
policy. We will rely on the compiler shipped within the official
TinyGo container image.</li>
<li><a href="https://github.com/bats-core/bats-core">bats</a>: used to write the
tests and automate their execution.</li>
<li><a href="https://github.com/kubewarden/kwctl/releases">kwctl</a>: CLI tool
provided by Kubewarden to run its policies outside of Kubernetes,
among other actions. This is covered in depth inside of <a href="writing-policies/go//testing-policies.html">this
section</a> of the documentation.</li>
</ul>
<h2 id="building-the-policy-1"><a class="header" href="#building-the-policy-1">Building the policy</a></h2>
<p>As a first step we need to build the policy, producing a WebAssembly
binary.</p>
<p>This can be done with this simple command:</p>
<pre><code class="language-shell">make wasm
</code></pre>
<p>This will pull the official TinyGo container image and run the build process
inside of an ephemeral container.</p>
<p>The compilation produces a file called <code>policy.wasm</code>.</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h2>
<p>We are going to use <a href="https://github.com/bats-core/bats-core">bats</a> to write and
automate our tests. Each test will be composed by the following steps:</p>
<ol>
<li>Run the policy using <code>kwctl</code>.</li>
<li>Perform some assertions against the output produced by the
<code>kwctl</code>.</li>
</ol>
<p>All the end-to-end tests are located inside of a file called <code>e2e.bats</code>. The
scaffolded project already includes such a file. We will just change its
contents to reflect how our policy behaves.</p>
<p>As a final note, the end-to-end tests we will use the same test fixtures files
we previously used inside of the Go unit tests.</p>
<p>The first test ensures a request is approved when no settings are provided:</p>
<pre><code class="language-bash">@test &quot;accept when no settings are provided&quot; {
  run kwctl run -r test_data/ingress.json policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # request is accepted
  [ $(expr &quot;$output&quot; : '.*&quot;allowed&quot;:true.*') -ne 0 ]
}
</code></pre>
<p>We can execute the end-to-end tests by using this command:</p>
<pre><code class="language-shell">make e2e-tests
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-shell">bats e2e.bats
 ✓ accept when no settings are provided

1 test, 0 failures
</code></pre>
<p>Let's write a test to ensure a request is approved when a user-defined constraint
is respected:</p>
<pre><code class="language-bash">@test &quot;accept user defined constraint is respected&quot; {
  run kwctl run  \
    -r test_data/ingress.json \
    --settings-json '{&quot;constrained_labels&quot;: {&quot;owner&quot;: &quot;^team-&quot;}}' \
    policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # request is accepted
  [ $(expr &quot;$output&quot; : '.*&quot;allowed&quot;:true.*') -ne 0 ]
}
</code></pre>
<p>Next, we can write a test to ensure a request is accepted when none of the
labels is on the deny list:</p>
<pre><code class="language-bash">@test &quot;accept labels are not on deny list&quot; {
  run kwctl run \
    -r test_data/ingress.json \
    --settings-json '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;bar&quot;]}' \
    policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # request is accepted
  [ $(expr &quot;$output&quot; : '.*&quot;allowed&quot;:true.*') -ne 0 ]
}
</code></pre>
<p>Let's improve the test coverage by adding a test that rejects a request
because one of the labels is on the deny list:</p>
<pre><code class="language-bash">@test &quot;reject because label is on deny list&quot; {
  run kwctl run \
    -r test_data/ingress.json \
    --settings-json '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;owner&quot;]}' \
    policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # request is rejected
  [ $(expr &quot;$output&quot; : '.*&quot;allowed&quot;:false.*') -ne 0 ]
  [[ &quot;$output&quot; == *&quot;Label owner is on the deny list&quot;* ]]
}
</code></pre>
<p>The following test ensures a request is rejected when one of its labels doesn't
satisfy the constraint provided by the user.</p>
<pre><code class="language-bash">@test &quot;reject because label doesn't pass validation constraint&quot; {
  run kwctl run \
    -r test_data/ingress.json \
    --settings-json '{&quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-\\d+$&quot;}}' \
    policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # request is rejected
  [ $(expr &quot;$output&quot; : '.*&quot;allowed&quot;:false.*') -ne 0 ]
  [[ &quot;$output&quot; == *&quot;The value of cc-center doesn't pass user-defined constraint&quot;* ]]
}
</code></pre>
<p>We want to ensure settings' validation is working properly. This can be done
with the following tests:</p>
<pre><code class="language-bash">@test &quot;fail settings validation because of conflicting labels&quot; {
  run kwctl run \
    -r test_data/ingress.json \
    --settings-json '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;cc-center&quot;], &quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-\\d+$&quot;}}' \
    policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation failed
  [ $(expr &quot;$output&quot; : '.*&quot;valid&quot;:false.*') -ne 0 ]
  [[ &quot;$output&quot; == *&quot;Provided settings are not valid: These labels cannot be constrained and denied at the same time: Set{cc-center}&quot;* ]]
}

@test &quot;fail settings validation because of invalid constraint&quot; {
  run kwctl run \
    -r test_data/ingress.json \
    --settings-json '{&quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-[12$&quot;}}' \
    policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  [[ &quot;$output&quot; == *&quot;Provided settings are not valid: error parsing regexp: missing closing ]: `[12$`&quot;* ]]
}
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>We have reached a pretty good level of coverage, let's run all the end-to-end
tests:</p>
<pre><code class="language-shell">$ make e2e-tests
bats e2e.bats
 ✓ accept when no settings are provided
 ✓ accept user defined constraint is respected
 ✓ accept labels are not on deny list
 ✓ reject because label is on deny list
 ✓ reject because label doesn't pass validation constraint
 ✓ fail settings validation because of conflicting labels
 ✓ fail settings validation because of invalid constraint

7 tests, 0 failures
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-1"><a class="header" href="#logging-1">Logging</a></h1>
<p>The Go SDK integrates with the <a href="https://github.com/francoispqt/onelog"><code>onelog</code></a> project almost out
of the box. The reasons why this library has been chosen are:</p>
<ul>
<li>
<p>It works with WebAssembly binaries. Other popular logging solutions cannot even be built to
WebAssembly.</p>
</li>
<li>
<p>It provides <a href="https://github.com/francoispqt/onelog#benchmarks">good performance</a>.</p>
</li>
<li>
<p>It supports structured logging.</p>
</li>
</ul>
<h2 id="initialize-logger-1"><a class="header" href="#initialize-logger-1">Initialize logger</a></h2>
<p>You first have to initialize a logger structure. By performing this initialization in a global
variable, you can easily log from the two main policy entry points: <code>validate</code> and
<code>validate_settings</code>. Let's initialize this structure in our main package:</p>
<pre><code class="language-go">var (
	logWriter = kubewarden.KubewardenLogWriter{}
	logger    = onelog.New(
		&amp;logWriter,
		onelog.ALL, // shortcut for onelog.DEBUG|onelog.INFO|onelog.WARN|onelog.ERROR|onelog.FATAL
	)
)
</code></pre>
<h2 id="consuming-the-logger-1"><a class="header" href="#consuming-the-logger-1">Consuming the logger</a></h2>
<p>Now, we can use the <code>logger</code> object to log from wherever we need in our policy:</p>
<pre><code class="language-go">func validate(payload []byte) ([]byte, error) {
	// ...
	logger.Info(&quot;validating request&quot;)
	// ...
}
</code></pre>
<p>Let's add some structured logging:</p>
<pre><code class="language-go">func validate(payload []byte) ([]byte, error) {
	// ...
	logger.WarnWithFields(&quot;logging something important&quot;, func(e onelog.Entry) {
		e.String(&quot;one_field&quot;, &quot;a value&quot;)
		e.String(&quot;another_field&quot;, &quot;another value&quot;)
	})
	// ...
}
</code></pre>
<p>You can refer to the <a href="https://pkg.go.dev/github.com/francoispqt/onelog?utm_source=godoc"><code>onelog</code>
documentation</a> for more
information.</p>
<p>The logging produced by the policy will be sent to the policy evaluator (<code>kwctl</code> or <code>policy-server</code>
for example), and they will log on behalf of the policy using mechanisms that are easily pluggable
to other components that enable distributed tracing, such as Jaeger.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automations"><a class="header" href="#automations">Automations</a></h1>
<p>This section describes how we can use GitHub Actions to automate as many tasks
as possible.</p>
<p>The scaffolded project already includes all the GitHub actions you need.
These Actions can be found in the <code>.github/workflows/ci.yml.template</code> file;
rename it to <code>github/workflows.ci/yml</code> to enable them.</p>
<p>The same principles can be adapted to use a different CI system.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Automation of the unit tests and of the end-to-end tests is working out of the
box thanks to the <code>unit-tests</code> and <code>e2e-tests</code> jobs defined in
<code>.github/workflows/ci.yml.template</code>.</p>
<h2 id="release"><a class="header" href="#release">Release</a></h2>
<p>The scaffolded project contains a <code>release</code> job in
<code>.github/workflows/ci.yml.template</code>.</p>
<p>This job performs the following steps:</p>
<ul>
<li>Checkout code</li>
<li>Build the WebAssembly policy</li>
<li>Push the policy to an OCI registry</li>
<li>Eventually create a new GitHub Release</li>
</ul>
<p>To enable the job you need to rename it to <code>ci.yml</code> and change the value of the
<code>OCI_TARGET</code> to match your preferences.</p>
<p>The job will act differently based on the commit that triggered its execution.</p>
<p>Regular commits will lead to the creation of an OCI artifact called <code>&lt;policy-name&gt;:latest</code>.
No GitHub Release will be created for these commits.</p>
<p>On the other hand, creating a tag that matches the <code>v*</code> pattern, will lead
to:</p>
<ol>
<li>Creation of an OCI artifact called <code>&lt;policy-name&gt;:&lt;tag&gt;</code>.</li>
<li>Creation of a GitHub Release named <code>Release &lt;full tag name&gt;</code>. The release
will include the following assets: the source code of the policy and the WebAssembly
binary.</li>
</ol>
<h3 id="a-concrete-example-2"><a class="header" href="#a-concrete-example-2">A concrete example</a></h3>
<p>Let's assume we have a policy named <code>safe-labels</code> and we want to publish
it as <code>ghcr.io/kubewarden/policies/safe-labels</code>.</p>
<p>The contents of the <code>jobs.push-to-oci-registry.env</code> section of <code>ci.yml</code> should
look like this:</p>
<pre><code class="language-yaml">jobs:
  push-to-oci-registry:
    runs-on: ubuntu-latest
    env:
      WASM_BINARY_NAME: policy.wasm
      OCI_TARGET: ghcr.io/kubewarden/policies/safe-labels
</code></pre>
<p>Pushing a tag named <code>v0.1.0</code> will lead to the creation and publishing of the
OCI artifact called <code>ghcr.io/kubewarden/policies/safe-labels:v0.1.0</code>.</p>
<p>A GitHub Release named <code>Release v0.1.0</code> will be created. The release will
include the following assets:</p>
<ul>
<li>Source code compressed as <code>zip</code> and <code>tar.gz</code></li>
<li>A file named <code>policy.wasm</code> that is the actual WebAssembly policy</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distribute-policy"><a class="header" href="#distribute-policy">Distribute policy</a></h1>
<p>Congratulations for having made this far 🎉🎉🎉</p>
<p>We hope you enjoyed the journey!</p>
<p>In case you haven't realized, we actually created the
<a href="https://github.com/kubewarden/safe-labels-policy">safe-labels-policy</a>
together.</p>
<p>There's nothing special to be done when it comes to distributing the
policy. If you followed this guide you have already published
your policy using the GitHub <code>release.yml</code> Action defined in the previous
chapter.</p>
<p>The topic of distributing policies is covered in depth inside of the
<a href="writing-policies/go//distributing-policies.html">&quot;distributing policies&quot;</a>
section of Kubewarden's documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<p>As stated on the <a href="https://swift.org/">official website</a>:</p>
<blockquote>
<p>Swift is a general-purpose programming language built using a modern approach
to safety, performance, and software design patterns.</p>
</blockquote>
<p>The swift compiler doesn't yet have WebAssembly support, however the
<a href="https://swiftwasm.org/">Swiftwasm</a> provides a patched compiler with this
capability.</p>
<p>The Swiftwasm team is also working to upstream all these changes into the
Swift project. In the meantime the toolchain provided by the Swiftwasm project
can be used to build Kubewarden policies.</p>
<p><strong>Note well:</strong> you don't need an Apple system to write or run Swift code. Everything
can be done also on a Linux machine or on Windows (by using Docker for Windows).</p>
<h2 id="current-state"><a class="header" href="#current-state">Current State</a></h2>
<p>Policy authors can leverage the following resources:</p>
<ul>
<li><a href="https://github.com/kubewarden/policy-sdk-swift">Kubewarden Swift SDK</a>: this
provides a set of <code>struct</code> and functions that simplify the process of
writing policies.</li>
<li><a href="https://github.com/kubewarden/swift-policy-template">Kubewarden Swift template project</a>:
use this template to quickly scaffold a Swift-based policy. The template comes
with a working policy and a set of GitHub Actions to automate its lifecycle.</li>
</ul>
<p>No severe limitations have been found inside of Swift, only
some minor glitches:</p>
<ul>
<li>It's critical to perform some post-build optimizations before using the
policy <em>&quot;in production&quot;</em>:
<ol>
<li>Strip the Wasm module via <code>wasm-strip</code> to reduce its size</li>
<li>Optimize the Wasm module via <code>wasm-opt</code></li>
</ol>
</li>
</ul>
<p>The GitHub Action provided by the template repository already takes care of that.</p>
<h2 id="more-examples-1"><a class="header" href="#more-examples-1">More examples</a></h2>
<p><a href="https://github.com/kubewarden/pod-runtime-class-policy">This GitHub repository</a>
contains a Kubewarden Policy written in Swift.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>As stated on the <a href="https://www.typescriptlang.org/">official website</a>:</p>
<blockquote>
<p>TypeScript extends JavaScript by adding types.</p>
<p>By understanding JavaScript, TypeScript saves you time catching errors and
providing fixes before you run code.</p>
</blockquote>
<p>TypeScript <strong>cannot</strong> be converted to WebAssembly, however
<a href="https://www.assemblyscript.org/">AssemblyScript</a> is a <strong>subset</strong> of TypeScript
designed explicitly for WebAssembly.</p>
<h2 id="current-state-1"><a class="header" href="#current-state-1">Current State</a></h2>
<p>Currently there's currently no Kubewarden SDK for AssemblyScript, we haven't
created it bacause of lack of time. We will do that in the near future.</p>
<p>In the meantime, there seem to be some limitatations affecting AssemblyScript:</p>
<ul>
<li>There's no built-in way to Serialize and Deserilize classed to
and from JSON. See <a href="https://github.com/AssemblyScript/assemblyscript/issues/292">this issue</a></li>
<li>It <em>seems</em> there's no JSON path library for AssemblyScript</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p><a href="https://github.com/kubewarden/pod-privileged-policy">This GitHub repository</a>
contains a Kubewarden Policy written in AssemblyScript.</p>
<p><strong>Worth of note:</strong> this repository has a series of GitHub Actions that automate
the following tasks:</p>
<ul>
<li>Run unit tests and code linting on pull requests and after code is merged
into the main branch</li>
<li>Build the policy in <code>release</code> mode and push it to a OCI registry as an
artifact</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributing-policies"><a class="header" href="#distributing-policies">Distributing Policies</a></h1>
<p>Kubewarden policies are Wasm binaries that are evaluated by the
Kubewarden Policy Server.</p>
<p>The Kubewarden policy server can load policies from these
sources:</p>
<ul>
<li>Local filesystem</li>
<li>HTTP(s) server</li>
<li>OCI compliant registry like <a href="https://github.com/distribution/distribution">Distribution</a>
and other container registries (GitHub container registry, Azure Container
Registry, Amazon ECR, Google Container Registry, ...)</li>
</ul>
<p>We think distributing Kubewarden policies via a regular OCI compliant
registry is the best choice. Container registries are basically a
mandatory requirement for any Kubernetes cluster. Having a single
place to store, and secure, all the artifacts required by a cluster
can be really handy.</p>
<h1 id="pushing-policies-to-an-oci-compliant-registry"><a class="header" href="#pushing-policies-to-an-oci-compliant-registry">Pushing policies to an OCI compliant registry</a></h1>
<p>The <a href="https://github.com/opencontainers/artifacts">OCI Artifacts</a>
specification allows to store any kind of binary blob inside of a
regular OCI compliant container registry.</p>
<p>The target OCI compliant registry <strong>must support artifacts</strong> in order
to successfully push a Kubewarden Policy to it.</p>
<p>The <a href="https://github.com/kubewarden/kwctl"><code>kwctl</code></a> command line tool
can be used to push a Kubewarden Policy to an OCI compliant registry.</p>
<h2 id="annotating-the-policy-2"><a class="header" href="#annotating-the-policy-2">Annotating the policy</a></h2>
<p>Annotating a policy is done by the <code>kwctl</code> CLI tool as well. The
process of annotating a Kubewarden policy is done by adding
WebAssembly custom sections to the policy binary. This means that the
policy metadata travels with the policy itself.</p>
<p>The <code>kwctl annotate</code> command needs two main inputs:</p>
<ul>
<li>
<p>The Kubewarden policy to be annotated, in the form of a local file
in the filesystem.</p>
</li>
<li>
<p>The annotations file, a file containing a YAML with the policy
metadata. This file is located somewhere in your filesystem, usually
in the root project of your policy.</p>
</li>
</ul>
<p>An example follows; we save this file as <code>metadata.yml</code> in the current
directory:</p>
<pre><code class="language-yaml">rules:
- apiGroups: [&quot;*&quot;]
  apiVersions: [&quot;*&quot;]
  resources: [&quot;*&quot;]
  operations: [&quot;*&quot;]
mutating: false
annotations:
  io.kubewarden.policy.title: palindromify
  io.kubewarden.policy.description: Allows you to reject palindrome names in resources and namespace names, or to only accept palindrome names
  io.kubewarden.policy.author: Name Surname &lt;name.surname@example.com&gt;
  io.kubewarden.policy.url: https://github.com/&lt;org&gt;/palindromify
  io.kubewarden.policy.source: https://github.com/&lt;org&gt;/palindromify
  io.kubewarden.policy.license: Apache-2.0
  io.kubewarden.policy.usage: |
    This is markdown text and as such allows you to define a free form usage text.

    This policy allows you to reject requests if:
    - The name of the resource is a palindrome name.
    - The namespace name where this resource is created has a palindrome name.

    This policy accepts the following settings:

    - `invert_behavior`: bool that inverts the policy behavior. If enabled, only palindrome names will be accepted.
</code></pre>
<p>Now, let's annotate the policy:</p>
<pre><code class="language-shell">$ kwctl annotate policy.wasm \
    --metadata-path metadata.yml \
    --output-path annotated-policy.wasm
</code></pre>
<p>This process performs some optimizations on the policy, so it's not
uncommon to end up with a smaller annotated policy than the original
one. This depends a lot on the toolchain that was used to produce the
unannotated WebAssembly object.</p>
<p>You can check with <code>kwctl inspect</code> that everything looks correct:</p>
<pre><code class="language-shell">$ kwctl inspect annotated-policy.wasm
# here you will see a colored output of the metadata you provided on the `metadata.yml` file. This information is now read from the WebAssembly custom sections
</code></pre>
<h2 id="pushing-the-policy-2"><a class="header" href="#pushing-the-policy-2">Pushing the policy</a></h2>
<p>Pushing an annotated policy can be done in this way:</p>
<pre><code class="language-shell">$ kwctl push annotated-policy.wasm \
              &lt;oci-registry&gt;/kubewarden-policies/palindromify-policy:v0.0.1
</code></pre>
<p>It is discouraged to push unannotated policies. This is why by default
<code>kwctl push</code> will reject to push such a policy to an OCI registry. If
you really want to push an unannotated policy you can use the
<code>--force</code> flag of <code>kwctl push</code>.</p>
<p>The policy can then be referenced from the Kubewarden Policy Server or
<code>kwctl</code> as
<code>registry://&lt;oci-registry&gt;/kubewarden-policies/palindromify-policy:v0.0.1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-certificate-authorities"><a class="header" href="#custom-certificate-authorities">Custom Certificate Authorities</a></h1>
<p>Both <code>kwctl</code> and <code>policy-server</code> allow you to pull policies from OCI registries and HTTP servers, as well as pushing to OCI registries. In this process, by default, HTTPS is enforced with host TLS verification.</p>
<p>The system CA store is used to validate the trusted chain of certificates presented by the OCI registry. In a regular Kubewarden installation, the <code>policy-server</code> will use the CA store shipped with its Linux container. In the client side, <code>kwctl</code> will use your operating system CA store.</p>
<p>If you are using the <a href="https://github.com/kubewarden/kubewarden-controller">Kubewarden Controller</a>,
you can configure the PolicyServer via their <code>spec</code> fields, as documented
<a href="distributing-policies/../operator-manual/policy-servers/01-custom-cert-auths.html">here</a>.</p>
<blockquote>
<p><strong>Important</strong>: the default behavior of <code>kwctl</code> and <code>policy-server</code> is to enforce HTTPS with trusted certificates matching the system CA store. You can interact with registries using untrusted certificates or even without TLS, by using the <code>insecure_sources</code> setting. This approach is <strong>highly discouraged</strong> in environments closer to production.</p>
</blockquote>
<h2 id="the-sourcesyaml-file"><a class="header" href="#the-sourcesyaml-file">The <code>sources.yaml</code> file</a></h2>
<p>The pull and push behavior of <code>kwctl</code> and <code>policy-server</code> can be tuned via the <code>sources.yaml</code> file.</p>
<p>This file can be provided both to <code>kwctl</code> and the <code>policy-server</code> in the <code>--sources-path</code> argument. Its structure is as follows:</p>
<pre><code class="language-yaml">insecure_sources:
  - &quot;registry-dev.example.com&quot;
  - &quot;registry-dev2.example.com:5500&quot;
source_authorities:
  &quot;registry-pre.example.com&quot;:
    - type: Path
      path: /opt/example.com/pki/ca-pre1-1.pem
    - type: Path
      path: /opt/example.com/pki/ca-pre1-2.der
  &quot;registry-pre2.example.com:5500&quot;:
    - type: Data
      data: |
            -----BEGIN CERTIFICATE-----
            ca-pre2 PEM cert
            -----END CERTIFICATE-----
</code></pre>
<p>This file can be provided in YAML or JSON format. All keys are optional, so the following are also valid <code>sources.yaml</code> files:</p>
<pre><code class="language-yaml">insecure_sources: [&quot;dev.registry.example.com&quot;]
</code></pre>
<p>As well as:</p>
<pre><code class="language-json">{
    &quot;source_authorities&quot;: {
        &quot;host.k3d.internal:5000&quot;: [
            {&quot;type&quot;: &quot;Data&quot;,&quot;data&quot;:&quot;pem cert 1&quot;},
            {&quot;type&quot;: &quot;Data&quot;,&quot;data&quot;:&quot;pem cert 2&quot;}
        ]
    }
}
</code></pre>
<h3 id="insecure-sources"><a class="header" href="#insecure-sources">Insecure sources</a></h3>
<p>Hosts listed in the <code>insecure_sources</code> configuration behave in a different way than hosts that are not listed.</p>
<ul>
<li>
<p>Unlisted hosts (default)</p>
<ul>
<li>Try to connect using HTPS, verifying the server identity. If the connection fails, operation is aborted.</li>
</ul>
</li>
<li>
<p>Listed hosts</p>
<ul>
<li>Try to connect using HTTPS verifying the server identity. If the connection fails,</li>
<li>Try to connect using HTTPS, skipping host verification. If the connection fails,</li>
<li>Try to connect using HTTP. If the connection fails, operation is aborted.</li>
</ul>
</li>
</ul>
<p>It is generally fine to use <code>insecure_sources</code> when using local registries or
HTTP servers when developing locally, to avoid the certificate burden. However,
this setting is <strong>completely discouraged</strong> for environments closer to
production.</p>
<h3 id="source-authorities"><a class="header" href="#source-authorities">Source authorities</a></h3>
<p>The <code>source_authorities</code> is a map that contains URIs and a list of CA
certificates that form a certificate chain for that URI, used to verify the
identity of OCI registries and HTTPs servers.</p>
<p>These certificates can be encoded in PEM or DER format. Certificates in binary
DER format can be provided as a path to a file containing the certificate,
meanwhile certificates in PEM format can either by a path to the certificate
file, or a string with the certificate contents. Both possibilities are
specified via a <code>type</code> key:</p>
<pre><code class="language-yaml">source_authorities:
  &quot;registry-pre.example.com&quot;:
    - type: Path
      path: /opt/example.com/pki/ca-pre1-1.pem
    - type: Path
      path: /opt/example.com/pki/ca-pre1-2.der
    - type: Data
      data: |
            -----BEGIN CERTIFICATE-----
            ca-pre1-3 PEM cert
            -----END CERTIFICATE-----
  &quot;registry-pre2.example.com:5500&quot;:
    - type: Path
      path: /opt/example.com/pki/ca-pre2-1.der
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oci-registries-support"><a class="header" href="#oci-registries-support">OCI Registries support</a></h1>
<blockquote>
<p><strong>Note well</strong>: this is not an exhaustive list. If a registry you know or use is working correctly
with Kubewarden, or if any information described here is not accurate at this time, please open a
<a href="https://github.com/kubewarden/docs">Pull Request against this documentation</a> to fix it.</p>
</blockquote>
<p>Kubewarden policies are distributed as <a href="https://github.com/opencontainers/artifacts">OCI Artifacts</a>
using regular OCI Registries.</p>
<p>Policies are stored side by side with container images. They don't require any extra setup or
maintenance than regular container images do.</p>
<h2 id="projects"><a class="header" href="#projects">Projects</a></h2>
<ul>
<li><a href="https://github.com/distribution/distribution">Distribution</a></li>
</ul>
<h2 id="hosted-registries"><a class="header" href="#hosted-registries">Hosted registries</a></h2>
<ul>
<li><a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry">GitHub container registry</a></li>
</ul>
<h2 id="known-issues"><a class="header" href="#known-issues">Known issues</a></h2>
<h3 id="docker-hub"><a class="header" href="#docker-hub">Docker Hub</a></h3>
<p>The Docker Hub does not support OCI artifacts at this time, and as such, it cannot be used to store
Kubewarden policies.</p>
<h3 id="jfrog"><a class="header" href="#jfrog">JFrog</a></h3>
<p>Although JFrog supports OCI artifacts, it is only partially possible to push to it when following
the specification. <a href="https://github.com/kubewarden/kwctl/issues/59">Read more here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-policies"><a class="header" href="#testing-policies">Testing Policies</a></h1>
<p>This section covers the topic of testing Kubewarden Policies. There are two possible
personas interested in testing policies:</p>
<ul>
<li>As a policy author: you're writing a Kubewarden Policy and you want to ensure
your code behaves the way you expect.</li>
<li>As an end user: you found a Kubewarden Policy and you want to tune/test the policy
settings before deploying it, maybe you want to keep testing these settings
inside of your CI/CD pipelines,...</li>
</ul>
<p>The next sections of the documentation will show how Kubewarden policies can
be tested by these two personas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="while-creating-a-policy"><a class="header" href="#while-creating-a-policy">While creating a policy</a></h1>
<p>Kubewarden Policies are regular programs compiled as WebAssembly. As with any kind
of program, it's important to have good test coverage.</p>
<p>Policy authors can leverage the testing frameworks and tools of their language
of choice to verify the behaviour of their policies.</p>
<p>As an example, you can take a look at these Kubewarden policies:</p>
<ul>
<li><a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a>: this
is a Kubewarden Policy written using <a href="testing-policies//writing-policies/rust/01-intro.html">Rust</a>.</li>
<li><a href="https://github.com/kubewarden/ingress-policy">ingress-policy</a>: this is
a Kubewarden Policy written using <a href="testing-policies//writing-policies/go/01-intro.html">Go</a>.</li>
<li><a href="https://github.com/kubewarden/pod-privileged-policy">pod-privileged-policy</a>: this
is a Kubewarden Policy written using <a href="https://www.assemblyscript.org/">AssemblyScript</a>.</li>
</ul>
<p>All these policies have integrated test suites built using the regular testing libraries
of Rust, Go and AssemblyScript.</p>
<p>Finally, all these projects rely on GitHub Actions to implement their CI pipelines.</p>
<h2 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-end tests</a></h2>
<p>As a policy author you can also write tests that are executed against the actual
WebAssembly binary containing your policy. This can be done without having
to deploy a Kubernetes cluster by using these tools:</p>
<ul>
<li><a href="https://github.com/bats-core/bats-core">bats</a>: used to write the
tests and automate their execution.</li>
<li><a href="https://github.com/kubewarden/kwctl">kwctl</a>: Kubewarden go-to CLI
tool that helps you with policy related operations such as pull,
inspect, annotate, push and run.</li>
</ul>
<p><code>kwctl run</code> usage is quite simple, we just have to invoke it with the
following data as input:</p>
<ol>
<li>WebAssembly binary file reference of the policy to be run. The
Kubewarden policy can be loaded from the local filesystem
(<code>file://</code>), an HTTP(s) server (<code>https://</code>) or an OCI registry
(<code>registry://</code>).</li>
<li>The admission request object to be evaluated.  This is provided via
the <code>--request-path</code> argument. The request can be provided through
<code>stdin</code> by setting <code>--request-path</code> to <code>-</code>.</li>
<li>The policy settings to be used at evaluation time, they can be
provided as an inline JSON via <code>--settings-json</code> flag, or a JSON or
YAML file loaded from the filesystem via <code>--settings-path</code>.</li>
</ol>
<p>Once the policy evaluation is done, <code>kwctl</code> prints the
<code>ValidationResponse</code> object to the standard output.</p>
<p>For example, this is how <code>kwctl</code> can be used to test the WebAssembly
binary of the <code>ingress-policy</code> linked above:</p>
<pre><code>$ curl https://raw.githubusercontent.com/kubewarden/ingress-policy/v0.1.8/test_data/ingress-wildcard.json 2&gt; /dev/null | \
    kwctl run \
        --settings-json '{&quot;allowPorts&quot;: [80], &quot;denyPorts&quot;: [3000]}' \
        --request-path - \
        registry://ghcr.io/kubewarden/policies/ingress:v0.1.8 | jq
</code></pre>
<p>Using <code>bats</code> we can can write a test that runs this command and looks for the
expected outputs:</p>
<pre><code class="language-bash">@test &quot;all is good&quot; {
  run kwctl run \
    --request-path test_data/ingress-wildcard.json \
    --settings-json '{&quot;allowPorts&quot;: [80], &quot;denyPorts&quot;: [3000]}' \
    ingress-policy.wasm

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request accepted
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>We can copy the snippet from above inside of a file called <code>e2e.bats</code>,
and then invoke <code>bats</code> in this way:</p>
<pre><code>$ bats e2e.bats
 ✓ all is good

1 tests, 0 failures
</code></pre>
<p>Checkout <a href="testing-policies//writing-policies/go/05-e2e-tests.html">this section</a>
of the documentation to learn more about writing end-to-end
tests of your policies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="before-deployment"><a class="header" href="#before-deployment">Before deployment</a></h1>
<p>As a Kubernetes cluster operator you probably want to perform some tests
against a Kubewarden policy you just found.</p>
<p>You probably want to answer questions like:</p>
<ul>
<li>What are the correct policy settings to get the validation/mutation outcome
I desire?</li>
<li>How can I be sure everything will keep working as expected when I upgrade
the policy to a newer version, when I add/change some Kubernetes resources,
when I change the configuration parameters of the policy,...</li>
</ul>
<p>Kubewarden has a dedicated utility that allows testing of the policies
outside of Kubernetes, among other operations. This utility is called
<a href="https://github.com/kubewarden/kwctl"><code>kwctl</code></a>.</p>
<p><code>kwctl</code> usage is quite simple, we just have to invoke it with the
following data as input:</p>
<ol>
<li>WebAssembly binary file reference of the policy to be run. The
Kubewarden policy can be loaded from the local filesystem
(<code>file://</code>), an HTTP(s) server (<code>https://</code>) or an OCI registry
(<code>registry://</code>).</li>
<li>The admission request object to be evaluated.  This is provided via
the <code>--request-path</code> argument. The request can be provided through
<code>stdin</code> by setting <code>--request-path</code> to <code>-</code>.</li>
<li>The policy settings to be used at evaluation time, they can be
provided as an inline JSON via <code>--settings-json</code> flag, or a JSON or
YAML file loaded from the filesystem via <code>--settings-path</code>.</li>
</ol>
<p>Once the policy evaluation is done, <code>kwctl</code> prints the
<code>ValidationResponse</code> object to the standard output.</p>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>You can download pre-built binaries of <code>kwctl</code> from
<a href="https://github.com/kubewarden/kwctl/releases">here</a>.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>This section describes how to test the
<a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a> policy with
different configurations and validation request objects as input data.</p>
<h3 id="create-admissionreview-requests"><a class="header" href="#create-admissionreview-requests">Create <code>AdmissionReview</code> requests</a></h3>
<p>We have to create some files holding the <code>AdmissionReview</code> objects
that will be evaluated by the policy.</p>
<p>Let's create a file named <code>pod-req-no-specific-apparmor-profile.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;no-apparmor&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod that doesn't specify any AppArmor
profile to be used, that's because it doesn't have an <code>annotation</code>
with the <code>container.apparmor.security.beta.kubernetes.io/&lt;name of the container&gt;</code> key.</p>
<p>Let's create a file named <code>pod-req-apparmor-unconfined.json</code> with the
following contents:</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;unconfined&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod with a container called <code>nginx</code> that runs
with the <code>unconfined</code> AppArmor profile. Note well, running in <code>unconfined</code> mode
is a bad security practice.</p>
<p>Finally, let's create a file named <code>pod-req-apparmor-custom.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;localhost/nginx-custom&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<blockquote>
<p><strong>Note well:</strong> these are stripped down <code>AdmissionReview</code> objects, we
left only the fields that are relevant to our policy.</p>
</blockquote>
<h3 id="test-the-policy"><a class="header" href="#test-the-policy">Test the policy</a></h3>
<p>Now we can use <code>kwctl</code> to test the creation of a Pod that doesn't
specify an AppArmor profile:</p>
<pre><code class="language-console">$ kwctl run \
    --request-path pod-req-no-specific-apparmor-profile.json \
    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq
</code></pre>
<p>The policy will accept the request and produce the following output:</p>
<pre><code class="language-console">{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: true
}
</code></pre>
<p>The policy will instead reject the creation of a Pod with an
<code>unconfined</code> AppArmor profile:</p>
<pre><code class="language-console">$ kwctl run \
    --request-path pod-req-apparmor-unconfined.json \
    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq
{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: false,
  &quot;status&quot;: {
    &quot;message&quot;: &quot;These AppArmor profiles are not allowed: [\&quot;unconfined\&quot;]&quot;
  }
}
</code></pre>
<p>Both times we ran the policy <strong>without</strong> providing any kind of
setting. As the <a href="https://github.com/kubewarden/psp-apparmor#configuration">policy's
documentation</a>
states, this results in preventing the usage of non-default profiles.</p>
<p>As a matter of fact, the Pod using a custom <code>nginx</code> profile gets rejected by
the policy too:</p>
<pre><code class="language-console">$ kwctl run \
    --request-path pod-req-apparmor-custom.json \
    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq
{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: false,
  &quot;status&quot;: {
    &quot;message&quot;: &quot;These AppArmor profiles are not allowed: [\&quot;localhost/nginx-custom\&quot;]&quot;
  }
}
</code></pre>
<p>We can change the default behaviour and allow some chosen AppArmor to be used:</p>
<pre><code class="language-console">$ kwctl run \
    --request-path pod-req-apparmor-custom.json \
    --settings-json '{&quot;allowed_profiles&quot;: [&quot;runtime/default&quot;, &quot;localhost/nginx-custom&quot;]}' \
    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4 | jq
</code></pre>
<p>This time the request is accepted:</p>
<pre><code class="language-console">{
  &quot;uid&quot;: &quot;1299d386-525b-4032-98ae-1949f69f9cfc&quot;,
  &quot;allowed&quot;: true
}
</code></pre>
<h2 id="automation"><a class="header" href="#automation">Automation</a></h2>
<p>All these steps shown above can be automated using
<a href="https://github.com/bats-core/bats-core">bats</a>.</p>
<p>We can write a series of tests and integrate their execution inside of
your existing CI and CD pipelines.</p>
<p>That would ensure changes to the policy version, policy configuration
parameters, Kubernetes resources,... won't break the outcome of the
validation/mutation operations.</p>
<p>The commands used above can be easily &quot;wrapped&quot; into a <code>bats</code> test:</p>
<pre><code class="language-bash">@test &quot;all is good&quot; {
  run kwctl run \
    --request-path pod-req-no-specific-apparmor-profile.json \
    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # request accepted
  [ $(expr &quot;$output&quot; : '.*&quot;allowed&quot;:true.*') -ne 0 ]
}

@test &quot;reject&quot; {
  run kwctl run \
    --request-path pod-req-apparmor-custom.json \
    registry://ghcr.io/kubewarden/policies/psp-apparmor:v0.1.4

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # request rejected
  [ $(expr &quot;$output&quot; : '.*&quot;allowed&quot;:false.*') -ne 0 ]
}
</code></pre>
<p>Assuming the snippet from above is inside of a file called <code>e2e.bats</code>,
we can run the test in this way:</p>
<pre><code>$ bats e2e.bats
 ✓ all is good
 ✓ reject

2 tests, 0 failures
</code></pre>
<p>Checkout <a href="testing-policies//writing-policies/go/05-e2e-tests.html">this section</a> of the
documentation to learn more about writing end-to-end tests of your
policies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-manual"><a class="header" href="#operator-manual">Operator Manual</a></h1>
<p>This section covers topics related with the deployment and the operational
aspects of Kubewarden.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-policyservers"><a class="header" href="#configuring-policyservers">Configuring PolicyServers</a></h1>
<h2 id="custom-certificate-authorities-for-policy-registries"><a class="header" href="#custom-certificate-authorities-for-policy-registries">Custom Certificate Authorities for Policy registries</a></h2>
<p>It is possible to specify and configure the Certificate Authorities that a
PolicyServer uses when pulling the ClusterAdmissionPolicy artifacts from the
policy registry. The following <code>spec</code> fields will configure the deployed
<code>policy-server</code> executable to that effect.</p>
<h3 id="insecure-sources-1"><a class="header" href="#insecure-sources-1">Insecure sources</a></h3>
<blockquote>
<p><strong>Important</strong>: the default behavior of <code>kwctl</code> and <code>policy-server</code> is to
enforce HTTPS with trusted certificates matching the system CA store. You can
interact with registries using untrusted certificates or even without TLS, by
using the <code>insecure_sources</code> setting. This approach is <strong>highly discouraged</strong>
for environments closer to production.</p>
</blockquote>
<p>To configure the PolicyServer to accept insecure connections to specific
registries, use the <code>spec.insecureSources</code> field of PolicyServer. This field
accepts a list of URIs to be regarded as insecure. Example:</p>
<pre><code class="language-yaml">spec:
  insecureSources:
    - localhost:5000
    - host.k3d.internal:5000
</code></pre>
<p>See <a href="operator-manual/policy-servers/../../distributing-policies/custom-certificate-authorities.html">here</a> for more
information on how the <code>policy-server</code> executable treats them.</p>
<h3 id="custom-certificate-authorities-1"><a class="header" href="#custom-certificate-authorities-1">Custom Certificate Authorities</a></h3>
<p>To configure the PolicyServer with a custom certificate chain of 1 or more
certificates for a specific URI, use the field <code>spec.sourceAuthorities</code>.</p>
<p>This field is a map of URIs, each with its own list of strings that contain PEM
encoded certificates. Example:</p>
<pre><code class="language-yaml">spec:
  sourceAuthorities:
    &quot;registry-pre.example.com&quot;:
      - |
        -----BEGIN CERTIFICATE-----
        ca-pre1-1 PEM cert
        -----END CERTIFICATE-----
      - |
        -----BEGIN CERTIFICATE-----
        ca-pre1-2 PEM cert
        -----END CERTIFICATE-----
    &quot;registry-pre2.example.com:5500&quot;:
      - |
        -----BEGIN CERTIFICATE-----
        ca-pre2 PEM cert
        -----END CERTIFICATE-----
</code></pre>
<p>See <a href="operator-manual/policy-servers//distributing-policies/custom-certificate-authorities.html">here</a> for more
information on how the <code>policy-server</code> executable treats them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opentelemetry"><a class="header" href="#opentelemetry">OpenTelemetry</a></h1>
<p><a href="https://opentelemetry.io/">OpenTelemetry</a> is a Cloud Native Computing Foundation framework for
observability. It enables your microservices to provide metrics, logs and traces.</p>
<p>Kubewarden's components are instrumented with the OpenTelemetry SDK, reporting data to an
OpenTelemetry collector -- called the agent.</p>
<p>By following this documentation, we will integrate OpenTelemetry using the following architecture:</p>
<ul>
<li>Each Pod of the Kubewarden stack will have a OpenTelemetry sidecar.</li>
<li>The sidecar receives tracing and monitoring information from the Kubewarden component via the OpenTelemetry Protocol (OTLP)</li>
<li>The OpenTelemetry collector will:
<ul>
<li>Send the trace events to a central Jaeger instance</li>
<li>Expose Prometheus metrics on a specific port</li>
</ul>
</li>
</ul>
<p>For more information about the other deployment modes, please refer to the <a href="https://opentelemetry.io/docs/">OpenTelemetry official
documentation</a>.</p>
<p>Let's first deploy OpenTelemetry in a Kubernetes cluster, so we can reuse it in the next sections
that will address specifically tracing and metrics.</p>
<h2 id="setting-up-a-kubernetes-cluster"><a class="header" href="#setting-up-a-kubernetes-cluster">Setting up a Kubernetes cluster</a></h2>
<blockquote>
<p>This section gives step-by-step instructions to create a
Kubernetes cluster with an ingress controller enabled.</p>
<p>Feel free to skip this section if you already have a Kubernetes
cluster where you can define Ingress resources.</p>
</blockquote>
<p>We are going to create a testing Kubernetes cluster using <a href="https://minikube.sigs.k8s.io/docs/">minikube</a>.</p>
<p>minikube has many backends, in this case we will use the
<a href="https://minikube.sigs.k8s.io/docs/drivers/kvm2/">kvm2</a> driver
which relies on libvirt.</p>
<p>Assuming <code>libvirtd</code> is properly running on your machine, issue the
following command:</p>
<pre><code class="language-console">minikube start --driver=kvm2
</code></pre>
<p>The command will produce an output similar to the following one:</p>
<pre><code class="language-console">$ minikube start --driver=kvm2
😄  minikube v1.23.2 on Opensuse-Leap 15.3
✨  Using the kvm2 driver based on user configuration
👍  Starting control plane node minikube in cluster minikube
🔥  Creating kvm2 VM (CPUs=2, Memory=6000MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.22.2 on Docker 20.10.8 ...
    ▪ Generating certificates and keys ...
    ▪ Booting up control plane ...
    ▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use &quot;minikube&quot; cluster and &quot;default&quot; namespace by default
</code></pre>
<p>Now we have to enable the Ingress addon:</p>
<pre><code class="language-console">minikube addons enable ingress
</code></pre>
<p>This will produce an output similar to the following one:</p>
<pre><code class="language-console">$ minikube addons enable ingress
    ▪ Using image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0
    ▪ Using image k8s.gcr.io/ingress-nginx/controller:v1.0.0-beta.3
    ▪ Using image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.0
🔎  Verifying ingress addon...
🌟  The 'ingress' addon is enabled
</code></pre>
<h2 id="install-opentelemetry"><a class="header" href="#install-opentelemetry">Install OpenTelemetry</a></h2>
<p>We are going to use the <a href="https://github.com/open-telemetry/opentelemetry-operator">OpenTelemetry Operator</a>
to manage the automatic injection of the OpenTelemetry Collector sidecar
inside of the PolicyServer pod.</p>
<p>The OpenTelemetry Operator requires <a href="https://cert-manager.io/docs/installation/">cert-manager</a>
to be installed inside of the cluster.</p>
<p>This can be done with this command:</p>
<pre><code class="language-console">kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.5.3/cert-manager.yaml
kubectl wait --for=condition=Available deployment --timeout=2m -n cert-manager --all
</code></pre>
<p>Once cert-manager is up and running, the OpenTelemetry operator can be installed in this way:</p>
<pre><code class="language-console">kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml
kubectl wait --for=condition=Available deployment --timeout=2m -n opentelemetry-operator-system --all
</code></pre>
<h2 id="opentelemetry-integration"><a class="header" href="#opentelemetry-integration">OpenTelemetry integration</a></h2>
<p>We can now move to the next chapters of the book to enable application metrics (via Prometheus
integration) and application tracing (via Jaeger integration).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p>This section describes how to enable metrics reporting on the Policy Server.</p>
<blockquote>
<p><strong>Note well</strong>: before continuing, make sure you completed the previous
<a href="operator-manual/telemetry/metrics/../opentelemetry/01-quickstart.html#install-opentelemetry">OpenTelemetry</a> section of this book. It
is required for this section to work correctly.</p>
</blockquote>
<p>We are going to use <a href="https://prometheus.io/">Prometheus</a> to scrape metrics exposed by the Policy
Server.</p>
<h2 id="install-prometheus"><a class="header" href="#install-prometheus">Install Prometheus</a></h2>
<p>We will use the <a href="https://github.com/prometheus-operator/prometheus-operator">Prometheus Operator</a>,
that allows us to intuitively define Prometheus' Targets.</p>
<p>There are many ways to install and set up Prometheus. For ease of deployment, we will use the
Prometheus community helm chart.</p>
<p>Let's add the helm repository from the Prometheus Community:</p>
<pre><code class="language-console">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
</code></pre>
<p>Now, let's install the
<a href="https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack"><code>kube-prometheus-stack</code></a>
chart. This chart contains a collection of Kubernetes manifests, Grafana dashboards, and Prometheus
rules.</p>
<p>Let's create a <code>kube-prometheus-stack-values.yaml</code> file to configure the <code>kube-prometheus-stack</code>
Helm chart values with the following contents:</p>
<pre><code class="language-yaml">prometheus:
  additionalServiceMonitors:
    - name: kubewarden
      selector:
        matchLabels:
          app: kubewarden-policy-server-default
      namespaceSelector:
        matchNames:
          - kubewarden
      endpoints:
        - port: metrics
          interval: 10s
</code></pre>
<p>The <code>prometheus-operator</code> deployed as part of this Helm chart defines the concept of <a href="https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/design.md#servicemonitor">Service
Monitors</a>,
used to declaratively define which services should be monitored by Prometheus.</p>
<p>In our case, we are adding a Service monitor targeting the <code>kubewarden</code> namespace, for services that
match labels <code>app=kubewarden-policy-server-default</code>. This way, the Prometheus Operator is able to
inspect which Kubernetes Endpoints are tied to services matching this conditions. The operator will
then take care of generating a valid configuration file for Prometheus, and reloading it
automatically after updating its configuration file.</p>
<pre><code class="language-console">helm install --wait --create-namespace --namespace prometheus --values kube-prometheus-stack-values.yaml prometheus prometheus-community/kube-prometheus-stack
</code></pre>
<h2 id="install-kubewarden"><a class="header" href="#install-kubewarden">Install Kubewarden</a></h2>
<p>We can now install Kubewarden in the recommended way with the Helm chart.</p>
<blockquote>
<p><strong>Note well:</strong> cert-manager is a requirement of Kubewarden, and OpenTelemetry is required for this
feature, but we've already installed them in a previous section of this book.</p>
</blockquote>
<p>As a first step, we have to add the Helm repository that contains Kubewarden:</p>
<pre><code class="language-console">helm repo add kubewarden https://charts.kubewarden.io
</code></pre>
<p>Then we have to install the Custom Resource Definitions (CRDs) defined by
Kubewarden:</p>
<pre><code class="language-console">helm install --wait --namespace kubewarden --create-namespace kubewarden-crds kubewarden/kubewarden-crds
</code></pre>
<p>Now we can deploy the rest of the Kubewarden stack. The official helm
chart will create a PolicyServer named <code>default</code>.</p>
<p>Let's configure the values of the Helm Chart so that we have metrics enabled 
in Kubewarden. Write the <code>kubewarden-values.yaml</code> file with the following contents:</p>
<pre><code class="language-yaml">telemetry:
  enabled: True
policyServer:
    metrics:
      port: 8080
</code></pre>
<p>Now, let's install the helm chart:</p>
<pre><code class="language-console">helm install --wait --namespace kubewarden --values kubewarden-values.yaml kubewarden-controller kubewarden/kubewarden-controller
</code></pre>
<p>This leads to the creation of the <code>default</code> instance of <code>PolicyServer</code>:</p>
<pre><code class="language-console">kubectl get policyservers.policies.kubewarden.io
NAME      AGE
default   3m7s
</code></pre>
<p>By default, this policy server will have metrics enabled.</p>
<h2 id="accessing-prometheus"><a class="header" href="#accessing-prometheus">Accessing Prometheus</a></h2>
<p>Prometheus exposes a very simple UI that we can use to inspect metrics exposed by different
components within our Kubernetes cluster.</p>
<p>We can forward the Prometheus port so we can easily access it.</p>
<pre><code class="language-console">kubectl port-forward -n prometheus --address 0.0.0.0 svc/prometheus-operated 9090
</code></pre>
<p>Now, we can visit prometheus through port <code>9090</code> and perform a query, for example:
<code>kubewarden_policy_evaluations_total</code>. We will see that the number of evaluations will grow over
time as we produce more requests that go through the policy.</p>
<h2 id="accessing-grafana"><a class="header" href="#accessing-grafana">Accessing Grafana</a></h2>
<p>We can forward the Grafana service so we can easily access it.</p>
<pre><code class="language-console">kubectl port-forward -n prometheus --address 0.0.0.0 svc/prometheus-grafana 8080:80
</code></pre>
<p>You can now login with the default username <code>admin</code> and password <code>prom-operator</code>.</p>
<h3 id="using-kubewarden-grafana-dashboard"><a class="header" href="#using-kubewarden-grafana-dashboard">Using Kubewarden Grafana dashboard</a></h3>
<p>The Kubewarden developers made available a Grafana dashboard with some basic metrics
that give an overview about how Kubewarden behaves inside of cluster. This dashboard
is available in the Kubewarden repository in a <a href="https://raw.githubusercontent.com/kubewarden/policy-server/main/kubewarden-dashboard.json">JSON file</a> 
or in the <a href="https://grafana.com/grafana/dashboards/15314">Grafana website</a>. </p>
<p>To import the dashboard into your environment, you can download the JSON file
from the Grafana website or from the repository:</p>
<pre><code class="language-console">curl https://raw.githubusercontent.com/kubewarden/policy-server/main/kubewarden-dashboard.json
</code></pre>
<p>Once you have the file in your machine you should access the Grafana dashboard and
<a href="https://grafana.com/docs/grafana/latest/dashboards/export-import/#import-dashboard">import it</a>.
Visit <code>/dashboard/import</code> in the Grafana dashboard and follow these steps:</p>
<ol>
<li>Copy the JSON file contents and paste them into the <code>Import via panel json</code> box in the Grafana UI</li>
<li>Click the <code>Load</code> button</li>
<li>Choosing <code>Prometheus</code> as the source</li>
<li>Click the <code>Import</code> button</li>
</ol>
<p>Another option is import it directly from the Grafana.com website. For this:</p>
<ol>
<li>Copy the dashboard ID from the <a href="https://grafana.com/grafana/dashboards/15314">dashboard page</a>, </li>
<li>Paste it in the <code>Import via grafana.com</code> field</li>
<li>Click the <code>load</code> button.</li>
<li>After importing the dashboard, define the Prometheus data source to use and finish
the import process. </li>
</ol>
<p>You should be able to see the dashboard similar to this:</p>
<p><img src="operator-manual/telemetry/metrics/./images/grafana_dashboard_1.png/" alt="Dashboard 1" />
<img src="operator-manual/telemetry/metrics/./images/grafana_dashboard_2.png/" alt="Dashboard 2" />
<img src="operator-manual/telemetry/metrics/./images/grafana_dashboard_3.png/" alt="Dashboard 3" />
<img src="operator-manual/telemetry/metrics/./images/grafana_dashboard_4.png/" alt="Dashboard 4" /></p>
<p>The Grafana dashboard has panes showing the state of all 
the policies managed by Kubewarden. Plus it has policy-specific panels.</p>
<p>Policy detailed metrics can be obtained by changing the value of the <code>policy_name</code>
variable to match the name of the desired policy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics-reference"><a class="header" href="#metrics-reference">Metrics Reference</a></h1>
<p>Kubewarden exposes some relevant metrics that enhance visibility of the platform, and allows cluster
administrators and policy developers to identify patterns and potential issues.</p>
<h2 id="policy-server-1"><a class="header" href="#policy-server-1">Policy Server</a></h2>
<p>The Policy Server is the component that initializes and runs policies. Upon receiving requests from
the Kubernetes API server, it will forward the request to the policy, and return the response
provided by the policy to the Kubernetes API server.</p>
<h3 id="metrics-1"><a class="header" href="#metrics-1">Metrics</a></h3>
<blockquote>
<p><strong>Note</strong>: Baggage are key-value attributes added to the metric. They are used to enrich the metric
with additional information.</p>
</blockquote>
<table><thead><tr><th>Name</th><th>Type</th><th></th></tr></thead><tbody>
<tr><td><code>kubewarden_policy_evaluations_total</code></td><td>Counter</td><td><a href="operator-manual/telemetry/metrics/02-reference.html#kubewarden_policy_evaluations_total">Baggage</a></td></tr>
</tbody></table>
<h4 id="kubewarden_policy_evaluations_total"><a class="header" href="#kubewarden_policy_evaluations_total"><code>kubewarden_policy_evaluations_total</code></a></h4>
<h5 id="baggage"><a class="header" href="#baggage">Baggage</a></h5>
<table><thead><tr><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td><code>policy_name</code></td><td>Name of the policy</td></tr>
<tr><td><code>resource_name</code></td><td>Name of the evaluated resource</td></tr>
<tr><td><code>resource_kind</code></td><td>Kind of the evaluated resource</td></tr>
<tr><td><code>resource_namespace</code></td><td>Namespace of the evaluated resource. Not present if the resource is cluster scoped.</td></tr>
<tr><td><code>resource_request_operation</code></td><td>Operation type: <code>CREATE</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>PATCH</code>, <code>WATCH</code>...</td></tr>
<tr><td><code>accepted</code></td><td>Whether the request was accepted or not</td></tr>
<tr><td><code>mutated</code></td><td>Whether the request was mutated or not</td></tr>
<tr><td><code>error_code</code></td><td>Error code returned by the policy in case of rejection, if any. Not present if the policy didn't provide one.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracing"><a class="header" href="#tracing">Tracing</a></h1>
<p>This section illustrates how to enable tracing support of
Policy Server.</p>
<blockquote>
<p><strong>Note well</strong>: before continuing, make sure you completed the previous
<a href="operator-manual/telemetry/tracing/../opentelemetry/01-quickstart.html#install-opentelemetry">OpenTelemetry</a> section of this book. It
is required for this section to work correctly.</p>
</blockquote>
<p>Tracing allows to collect fine grained details about policy evaluations. It can
be a useful tool for debugging issues inside of your Kubewarden deployment and policies.</p>
<p>We will use <a href="https://www.jaegertracing.io/">Jaeger</a> -- used to receive, store and visualize trace
events.</p>
<h2 id="install-jaeger"><a class="header" href="#install-jaeger">Install Jaeger</a></h2>
<p>We are going to use the <a href="https://github.com/jaegertracing/jaeger-operator">Jaeger Operator</a>
to manage all the different Jaeger components.</p>
<p>The operator can be installed in many ways, we are going to use
its helm chart.</p>
<p>As a first step, we need to add the helm repository containing the Jaeger Operator
charts:</p>
<pre><code class="language-console">helm repo add jaegertracing https://jaegertracing.github.io/helm-charts
</code></pre>
<p>Then we install the operator inside of a dedicated Namespace called <code>jaeger</code>:</p>
<pre><code class="language-console">helm install --namespace jaeger --create-namespace jaeger-operator jaegertracing/jaeger-operator
</code></pre>
<p>This will produce an output similar to the following one:</p>
<pre><code class="language-console">helm install --namespace jaeger --create-namespace jaeger-operator jaegertracing/jaeger-operator
manifest_sorter.go:192: info: skipping unknown hook: &quot;crd-install&quot;
NAME: jaeger-operator
LAST DEPLOYED: Tue Sep 28 14:54:02 2021
NAMESPACE: jaeger
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
jaeger-operator is installed.


Check the jaeger-operator logs
  export POD=$(kubectl get pods -l app.kubernetes.io/instance=jaeger-operator -lapp.kubernetes.io/name=jaeger-operator --namespace jaeger --output name)
  kubectl logs $POD --namespace=jaeger
</code></pre>
<p>Given this is a testing environment, we will use default
<a href="https://www.jaegertracing.io/docs/1.26/operator/#allinone-default-strategy">&quot;AllInOne&quot;</a>
strategy. As stated on the upstream documentation: this deployment strategy is
meant to be used only for development, testing and demo purposes.</p>
<blockquote>
<p><strong>Note well:</strong> the operator can deploy Jaeger in many different ways. We strongly recommend
to read its <a href="https://www.jaegertracing.io/docs/1.26/operator/">official documentation</a>.</p>
</blockquote>
<p>Let's create a Jaeger resource:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: all-in-one
  namespace: jaeger
spec:
  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
EOF
</code></pre>
<p>Once all the resources have been created by the Jaeger operator, the
Jaeger Query UI will be reachable at the following address:</p>
<pre><code class="language-console">echo http://`minikube ip`
</code></pre>
<h2 id="install-kubewarden-1"><a class="header" href="#install-kubewarden-1">Install Kubewarden</a></h2>
<p>We can proceed to the deployment of Kubewarden in the usual way.</p>
<blockquote>
<p><strong>Note well:</strong> cert-manager is a requirement of Kubewarden, and OpenTelemetry is required for this
feature, but we've already installed them in a previous section of this book.</p>
</blockquote>
<p>As a first step, we have to add the Helm repository that contains Kubewarden:</p>
<pre><code class="language-console">helm repo add kubewarden https://charts.kubewarden.io
</code></pre>
<p>Then we have to install the Custom Resource Definitions (CRDs) defined by
Kubewarden:</p>
<pre><code class="language-console">helm install --wait --namespace kubewarden --create-namespace kubewarden-crds kubewarden/kubewarden-crds
</code></pre>
<p>Now we can deploy the rest of the Kubewarden stack. The official
helm chart will create a PolicyServer named <code>default</code>. We want this PolicyServer
instance to have tracing enabled.</p>
<p>In order to do that, we have to specify some extra values at installation time.
Let's create a <code>values.yaml</code> file with the following contents:</p>
<pre><code class="language-yaml">policyServer:
  telemetry:
    enabled: True
    tracing:
      jaeger:
        endpoint: &quot;all-in-one-collector.jaeger.svc.cluster.local:14250&quot;
</code></pre>
<p>Then we can proceed with the installation of the helm chart:</p>
<pre><code class="language-console">helm install --wait --namespace kubewarden --create-namespace --values values.yaml kubewarden-controller kubewarden/kubewarden-controller
</code></pre>
<p>This leads to the creation of the <code>default</code> instance of <code>PolicyServer</code>:</p>
<pre><code class="language-console">kubectl get policyservers.policies.kubewarden.io
NAME      AGE
default   3m7s
</code></pre>
<p>Looking closer at the Pod running the PolicyServer instance, we will find it has
two containers inside of it: the actual <code>policy-server</code> and the OpenTelemetry
Collector sidecar <code>otc-container</code>.</p>
<h2 id="enforcing-a-policy"><a class="header" href="#enforcing-a-policy">Enforcing a policy</a></h2>
<p>We will start by deploying the <a href="https://github.com/kubewarden/safe-labels-policy">safe-labels</a>
policy.</p>
<p>We want the policy to be enforced only inside of Namespaces that have a
label <code>environment</code> with value <code>production</code>.</p>
<p>Let's create a Namespace that has such a label:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Namespace
metadata:
  name: team-alpha-prod
  labels:
    environment: production
EOF
</code></pre>
<p>Next, let's define a ClusterAdmissionPolicy:</p>
<pre><code class="language-yaml">kubectl apply -f - &lt;&lt;EOF
apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: safe-labels
spec:
  module: registry://ghcr.io/kubewarden/policies/safe-labels:v0.1.6
  settings:
    mandatory_labels:
    - owner
  rules:
    - apiGroups:
        - apps
      apiVersions:
        - v1
      resources:
        - deployments
      operations:
        - CREATE
        - UPDATE
  namespaceSelector:
    matchExpressions:
    - key: environment
      operator: In
      values: [&quot;production&quot;]
  mutating: false
EOF
</code></pre>
<p>We can wait for the policy to be active in this way:</p>
<pre><code class="language-console">kubectl wait --for=condition=PolicyActive clusteradmissionpolicy/safe-labels
</code></pre>
<p>Once the policy is active, we can try it out in this way:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  namespace: team-alpha-prod
  labels:
    owner: flavio
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 0
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
EOF
</code></pre>
<p>This Deployment object will be created because it doesn't violate the policy.</p>
<p>On the other hand, this Deployment will be blocked by the policy:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment-without-labels
  namespace: team-alpha-prod
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 0
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
EOF
</code></pre>
<p>The policy is not enforced inside of another Namespace.</p>
<p>The following command creates a new Namespace called <code>team-alpha-staging</code>:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Namespace
metadata:
  name: team-alpha-staging
  labels:
    environment: staging
EOF
</code></pre>
<p>As expected, the creation of a Deployment resource that doesn't have any label
is allowed inside of the <code>team-alpha-staging</code> Namespace:</p>
<pre><code>kubectl apply -f - &lt;&lt;EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment-without-labels
  namespace: team-alpha-staging
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 0
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
EOF
</code></pre>
<p>As expected, this resource is successfully created.</p>
<h2 id="exploring-the-jaeger-ui"><a class="header" href="#exploring-the-jaeger-ui">Exploring the Jaeger UI</a></h2>
<p>We can see the trace events have been sent by the PolicyServer instance to Jaeger:</p>
<p><img src="operator-manual/telemetry/tracing//operator-manual/tracing/jaeger-ui-home.png" alt="Jaeger homepage" title="The homepage of Jaeger" /></p>
<p>The Jaeger collector is properly receiving the traces generated by our PolicyServer.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
